<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html"><link rel="search" title="Search" href="../search.html">

    <!-- Generated with Sphinx 9.1.0 and Furo 2025.12.19 -->
        <title>astrix.spatial package - AsTrIX documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d111a655" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=7bdb33bb" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    
    


<style>
  body {
    --color-code-background: #f2f2f2;
  --color-code-foreground: #1e1e1e;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">AsTrIX  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <span class="sidebar-brand-text">AsTrIX  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting Started</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../examples.html">Examples</a><input aria-label="Toggle navigation of Examples" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../examples/example_1.html">Example 1 placeholder</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="index.html">API Reference</a><input aria-label="Toggle navigation of API Reference" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="astrix.time.html">astrix.time module</a></li>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.location.html">astrix.spatial.location module</a></li>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.frame.html">astrix.spatial.frame module</a></li>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.ray.html">astrix.spatial.ray module</a></li>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.rotation.html">astrix.spatial.rotation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="astrix.project.html">astrix.project module</a></li>
<li class="toctree-l2"><a class="reference internal" href="astrix.generic.html">astrix.generic module</a></li>
<li class="toctree-l2"><a class="reference internal" href="astrix.planning.html">astrix.planning module</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../_sources/api/astrix.spatial.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="module-astrix.spatial">
<span id="astrix-spatial-package"></span><h1>astrix.spatial package<a class="headerlink" href="#module-astrix.spatial" title="Link to this heading">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="astrix.spatial.Acceleration">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">Acceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_xp</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Acceleration"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Acceleration" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Acceleration vector(s) in ECEF coordinates (ax, ay, az) in m/s².
Associated with a Time object for the time instances of the accelerations.
Internal use only, typically created from Path objects.
No data validation is performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>vec</strong> (<em>Array</em>) – Acceleration vectors in ECEF coordinates (ax, ay, az) in m/s². Shape (n, 3).</p></li>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.html#astrix.Time" title="astrix.Time"><em>Time</em></a>) – Time object associated with the accelerations. Length must match number of acceleration vectors.</p></li>
<li><p><strong>backend</strong> (<em>BackendArg</em><em>, </em><em>optional</em>) – Array backend to use (numpy, jax, etc.). Defaults to numpy.</p></li>
<li><p><strong>_xp</strong> (<em>Any</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Acceleration.from_data">
<span class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Acceleration.from_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Acceleration.from_data" title="Link to this definition">¶</a></dt>
<dd><p>Create an Acceleration object from acceleration vector array and Time object.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration" title="astrix.spatial.location.Acceleration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Acceleration</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul>
<li><p><strong>vec</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>)</p></li>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><em>Time</em></a>)</p></li>
<li><p><strong>backend</strong> (<em>str</em><em> | </em><em>Any</em><em> | </em><em>None</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Acceleration.convert_to">
<span class="sig-name descname"><span class="pre">convert_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backend</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Acceleration.convert_to"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Acceleration.convert_to" title="Link to this definition">¶</a></dt>
<dd><p>Convert the Acceleration object to a different backend.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration" title="astrix.spatial.location.Acceleration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Acceleration</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>backend</strong> (<em>str</em><em> | </em><em>Any</em><em> | </em><em>None</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Acceleration.interp">
<span class="sig-name descname"><span class="pre">interp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Acceleration.interp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Acceleration.interp" title="Link to this definition">¶</a></dt>
<dd><p>Interpolate the Acceleration to the given times using the specified method.
Currently only ‘linear’ interpolation is supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration" title="astrix.spatial.location.Acceleration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Acceleration</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><em>Time</em></a>)</p></li>
<li><p><strong>method</strong> (<em>str</em>)</p></li>
<li><p><strong>check_bounds</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Acceleration.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rot</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Acceleration.rotate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Acceleration.rotate" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration" title="astrix.spatial.location.Acceleration"><code class="xref py py-class docutils literal notranslate"><span class="pre">Acceleration</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rot</strong> (<a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Acceleration.backend">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">backend</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">str</span></span><a class="headerlink" href="#astrix.spatial.Acceleration.backend" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Acceleration.magnitude">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">magnitude</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Any</span></span><a class="headerlink" href="#astrix.spatial.Acceleration.magnitude" title="Link to this definition">¶</a></dt>
<dd><p>Get the acceleration magnitude in m/s².</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="astrix.spatial.Acceleration.time">
<span class="sig-name descname"><span class="pre">time</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><span class="pre">Time</span></a></span><a class="headerlink" href="#astrix.spatial.Acceleration.time" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Acceleration.unit">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">unit</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Any</span></span><a class="headerlink" href="#astrix.spatial.Acceleration.unit" title="Link to this definition">¶</a></dt>
<dd><p>Get the unit acceleration vector.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="astrix.spatial.Acceleration.vec">
<span class="sig-name descname"><span class="pre">vec</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Any</span></span><a class="headerlink" href="#astrix.spatial.Acceleration.vec" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="astrix.spatial.Frame">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">Frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_frame</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'unnamed-frame'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/frame.html#Frame"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Frame" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A reference frame defined by a rotation and location.
Can be static or time-varying, and can have rotation defined relative to another Frame.
Combines RotationLike and Location objects, and manages time associations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>rot</strong> (<a class="reference internal" href="#astrix.spatial.Rotation" title="astrix.spatial.Rotation"><em>Rotation</em></a><em> | </em><a class="reference internal" href="#astrix.spatial.RotationSequence" title="astrix.spatial.RotationSequence"><em>RotationSequence</em></a>) – A scipy Rotation object (single rotation) or RotationSequence (time-tagged rotations).
If a single Rotation is provided, the frame rotation is static.</p></li>
<li><p><strong>loc</strong> (<a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Location" title="astrix.spatial.location.Location"><em>Location</em></a><em>, </em><em>optional</em>) – A Location object (Point or Path) defining the frame origin in ECEF coordinates.
If not provided, the frame origin is assumed to be at the origin of the reference frame.
If loc is provided, it must be a singular Point (1x3) for static frames.
Use Path objects for time-varying locations.</p></li>
<li><p><strong>ref_frame</strong> (<a class="reference internal" href="#astrix.spatial.Frame" title="astrix.spatial.Frame"><em>Frame</em></a><em>, </em><em>optional</em>) – A reference Frame object to define the rotation relative to.
If not provided, the rotation is assumed to be absolute (e.g., from ECEF frame).</p></li>
<li><p><strong>backend</strong> (<em>BackendArg</em><em>, </em><em>optional</em>) – Array backend to use (numpy, jax, etc.). Defaults to numpy.</p></li>
<li><p><strong>name</strong> (<em>str</em>)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Static frame with static rotation and location:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">astrix</span><span class="w"> </span><span class="kn">import</span> <span class="n">Frame</span><span class="p">,</span> <span class="n">Point</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot</span> <span class="o">=</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loc</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="n">from_geodet</span><span class="p">([</span><span class="o">-</span><span class="mf">27.47</span><span class="p">,</span> <span class="mf">153.03</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frame_static</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frame_static</span><span class="o">.</span><span class="n">interp_rot</span><span class="p">()</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[90.,  0.,  0.]])</span>
</pre></div>
</div>
<p>Time-varying frame with rotation sequence and static location:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">astrix</span><span class="w"> </span><span class="kn">import</span> <span class="n">Time</span><span class="p">,</span> <span class="n">RotationSequence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timezone</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">Time</span><span class="o">.</span><span class="n">from_datetime</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">),</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rots</span> <span class="o">=</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot_seq</span> <span class="o">=</span> <span class="n">RotationSequence</span><span class="p">(</span><span class="n">rots</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frame_dynamic</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="n">rot_seq</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_interp</span> <span class="o">=</span> <span class="n">Time</span><span class="o">.</span><span class="n">from_datetime</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frame_dynamic</span><span class="o">.</span><span class="n">interp_rot</span><span class="p">(</span><span class="n">t_interp</span><span class="p">)</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[45.,  0.,  0.]])</span>
</pre></div>
</div>
<p>Frame defined relative to another frame:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rot_ref</span> <span class="o">=</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frame_ref</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="n">rot_ref</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot_rel</span> <span class="o">=</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frame</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="n">rot_rel</span><span class="p">,</span> <span class="n">ref_frame</span><span class="o">=</span><span class="n">frame_ref</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frame</span><span class="o">.</span><span class="n">interp_rot</span><span class="p">()</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[ 0., 70.,  0.]])</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul>
<li><p>If both loc and ref_frame are provided, the new frame location is used and the reference frame location is disregarded.</p></li>
<li><p>A TimeGroup object is created internally to manage time associations between rotation, location, and reference frame.</p></li>
<li><p>If the frame is static (single rotation and singular Point), the time properties return TIME_INVARIANT.</p></li>
<li><p>Use Path objects for time-varying locations.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Frame.convert_to">
<span class="sig-name descname"><span class="pre">convert_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backend</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/frame.html#Frame.convert_to"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Frame.convert_to" title="Link to this definition">¶</a></dt>
<dd><p>Convert the Frame object to a different backend.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame" title="astrix.spatial.frame.Frame"><code class="xref py py-class docutils literal notranslate"><span class="pre">Frame</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>backend</strong> (<em>str</em><em> | </em><em>Any</em><em> | </em><em>None</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Frame.index_loc">
<span class="sig-name descname"><span class="pre">index_loc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/frame.html#Frame.index_loc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Frame.index_loc" title="Link to this definition">¶</a></dt>
<dd><p>Get the location of the frame at the given index.</p>
<p>Warning: This should only be used after downsampling so that rotation indices
are time-aligned. Use with caution. Prefer interp_loc for general use.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point" title="astrix.spatial.location.Point"><code class="xref py py-class docutils literal notranslate"><span class="pre">Point</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> (<em>int</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Frame.index_rot">
<span class="sig-name descname"><span class="pre">index_rot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/frame.html#Frame.index_rot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Frame.index_rot" title="Link to this definition">¶</a></dt>
<dd><p>Get the absolute rotation of the frame at the given index.</p>
<p>Warning: This should only be used after downsampling so that location
and rotation indeces align. Prefer interp_rot for general use.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> (<em>int</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Frame.interp_loc">
<span class="sig-name descname"><span class="pre">interp_loc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Time</span> <span class="pre">invariant</span> <span class="pre">(n=1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/frame.html#Frame.interp_loc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Frame.interp_loc" title="Link to this definition">¶</a></dt>
<dd><p>Get the interpolated location of the frame at the given times.
If the location is static, time can be None.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point" title="astrix.spatial.location.Point"><code class="xref py py-class docutils literal notranslate"><span class="pre">Point</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><em>Time</em></a>)</p></li>
<li><p><strong>check_bounds</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Frame.interp_rot">
<span class="sig-name descname"><span class="pre">interp_rot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Time</span> <span class="pre">invariant</span> <span class="pre">(n=1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/frame.html#Frame.interp_rot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Frame.interp_rot" title="Link to this definition">¶</a></dt>
<dd><p>Get the interpolated absolute rotation of the frame at the given times.
If all rotations are time invariant, time can be None.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><em>Time</em></a>)</p></li>
<li><p><strong>check_bounds</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Frame.replace_rot">
<span class="sig-name descname"><span class="pre">replace_rot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_rot</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/frame.html#Frame.replace_rot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Frame.replace_rot" title="Link to this definition">¶</a></dt>
<dd><p>Replace a rotation in the rotation chain with a new rotation.</p>
<p>This is an advanced feature and currently only applicable for static rotations.
Should primarily be used for optimisation purposes in autograd frameworks, such as
correcting misalignment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>frame_name</strong> (<em>str</em>) – Name of the frame whose rotation is to be replaced.</p></li>
<li><p><strong>new_rot</strong> (<a class="reference internal" href="#astrix.spatial.Rotation" title="astrix.spatial.Rotation"><em>Rotation</em></a>) – New scipy Rotation object to replace the existing rotation.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame" title="astrix.spatial.frame.Frame"><code class="xref py py-class docutils literal notranslate"><span class="pre">Frame</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Frame.sample_at_time">
<span class="sig-name descname"><span class="pre">sample_at_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/frame.html#Frame.sample_at_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Frame.sample_at_time" title="Link to this definition">¶</a></dt>
<dd><p>Sample the Frame object at specific times, returning a new Frame with
time-varying components sampled at those times. The new frame can then be
indexed at these times directly to avoid interpolation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>time</strong> (<a class="reference internal" href="astrix.html#astrix.Time" title="astrix.Time"><em>Time</em></a>) – Time object specifying the times to sample the Frame at.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New Frame object with components sampled at the specified times.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#astrix.spatial.Frame" title="astrix.spatial.Frame">Frame</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Frame.backend">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">backend</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">str</span></span><a class="headerlink" href="#astrix.spatial.Frame.backend" title="Link to this definition">¶</a></dt>
<dd><p>Get the name of the array backend in use (e.g., ‘numpy’, ‘jax’).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Frame.has_ref">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">has_ref</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></span><a class="headerlink" href="#astrix.spatial.Frame.has_ref" title="Link to this definition">¶</a></dt>
<dd><p>Check if the frame has a reference frame.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Frame.is_static">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">is_static</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></span><a class="headerlink" href="#astrix.spatial.Frame.is_static" title="Link to this definition">¶</a></dt>
<dd><p>Check if the frame is static (single rotation and singular Point location).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Frame.loc">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">loc</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Location" title="astrix.spatial.location.Location"><span class="pre">Location</span></a></span><a class="headerlink" href="#astrix.spatial.Frame.loc" title="Link to this definition">¶</a></dt>
<dd><p>Get the location of the frame in ECEF coordinates.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Frame.name">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">name</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">str</span></span><a class="headerlink" href="#astrix.spatial.Frame.name" title="Link to this definition">¶</a></dt>
<dd><p>Get the name of the frame.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Frame.name_chain">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">name_chain</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><a class="headerlink" href="#astrix.spatial.Frame.name_chain" title="Link to this definition">¶</a></dt>
<dd><p>Get the names of all frames in the rotation chain, from base to current.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Frame.path">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">path</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path" title="astrix.spatial.location.Path"><span class="pre">Path</span></a></span><a class="headerlink" href="#astrix.spatial.Frame.path" title="Link to this definition">¶</a></dt>
<dd><p>Get the time-varying Path of the frame location, if applicable.
If the frame location is static, raises AttributeError.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Frame.point">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">point</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point" title="astrix.spatial.location.Point"><span class="pre">Point</span></a></span><a class="headerlink" href="#astrix.spatial.Frame.point" title="Link to this definition">¶</a></dt>
<dd><p>Get the singular Point of the frame location, if applicable.
If the frame location is time-varying, raises AttributeError.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Frame.rel_rot">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">rel_rot</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.spatial.rotation.html#astrix.spatial.rotation.RotationLike" title="astrix.spatial.rotation.RotationLike"><span class="pre">RotationLike</span></a></span><a class="headerlink" href="#astrix.spatial.Frame.rel_rot" title="Link to this definition">¶</a></dt>
<dd><p>Get the last rotation of the frame relative to the reference frame.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Frame.time_bounds">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">time_bounds</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><span class="pre">Time</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><span class="pre">Time</span></a><span class="p"><span class="pre">]</span></span></span><a class="headerlink" href="#astrix.spatial.Frame.time_bounds" title="Link to this definition">¶</a></dt>
<dd><p>Get the time bounds of the frame as a tuple (start_time, end_time).
If the frame is static, returns TIME_INVARIANT.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Frame.time_group">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">time_group</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.time.html#astrix.time.TimeGroup" title="astrix.time.TimeGroup"><span class="pre">TimeGroup</span></a></span><a class="headerlink" href="#astrix.spatial.Frame.time_group" title="Link to this definition">¶</a></dt>
<dd><p>Get the Time object associated with the frame, if any.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="astrix.spatial.Path">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">Path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Path"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Path" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Location" title="astrix.spatial.location.Location"><code class="xref py py-class docutils literal notranslate"><span class="pre">Location</span></code></a></p>
<p>Path of multiple Point objects with associated Time.
Enables interpolation between points over time and calculation of velocity.
Must have at least 2 points with associated Time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>point</strong> (<a class="reference internal" href="#astrix.spatial.Point" title="astrix.spatial.Point"><em>Point</em></a><em> | </em><em>list</em><em> of </em><a class="reference internal" href="#astrix.spatial.Point" title="astrix.spatial.Point"><em>Point</em></a>) – Point object or list of Point objects with associated Time.
If a list is provided, all Points must have the same backend and associated Time.</p></li>
<li><p><strong>backend</strong> (<em>BackendArg</em><em>, </em><em>optional</em>) – Array backend to use (numpy, jax, etc.). Defaults to numpy.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Instantiating a Path from a list of Points:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">astrix</span><span class="w"> </span><span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Time</span><span class="p">,</span> <span class="n">Path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timezone</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">Time</span><span class="o">.</span><span class="n">from_datetime</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">datetime</span><span class="p">(</span><span class="mi">2025</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">datetime</span><span class="p">(</span><span class="mi">2025</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">datetime</span><span class="p">(</span><span class="mi">2025</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">),</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">Point</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="n">Point</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mf">3.8</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="n">Point</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
<span class="gp">... </span><span class="p">])</span>
</pre></div>
</div>
<p>Interpolate Path and get velocity:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t_interp</span> <span class="o">=</span> <span class="n">Time</span><span class="o">.</span><span class="n">from_datetime</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">datetime</span><span class="p">(</span><span class="mi">2025</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">500000</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t_interp</span><span class="p">)</span><span class="o">.</span><span class="n">ecef</span>
<span class="go">array([[2.5, 4.9, 0.7]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">vel</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t_interp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span><span class="o">.</span><span class="n">magnitude</span>
<span class="go">array([2.48997992])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Path.convert_to">
<span class="sig-name descname"><span class="pre">convert_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backend</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Path.convert_to"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Path.convert_to" title="Link to this definition">¶</a></dt>
<dd><p>Convert the Path object to a different backend.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path" title="astrix.spatial.location.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>backend</strong> (<em>str</em><em> | </em><em>Any</em><em> | </em><em>None</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Path.downsample">
<span class="sig-name descname"><span class="pre">downsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt_max</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Path.downsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Path.downsample" title="Link to this definition">¶</a></dt>
<dd><p>Downsample the Path to a maximum time step of dt_max seconds.
Note: This function is not JIT-compatible due to data validation checks.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path" title="astrix.spatial.location.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dt_max</strong> (<em>float</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Path.interp">
<span class="sig-name descname"><span class="pre">interp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Path.interp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Path.interp" title="Link to this definition">¶</a></dt>
<dd><p>Interpolate the Path to the given times using the specified method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.html#astrix.Time" title="astrix.Time"><em>Time</em></a>) – Times to interpolate to.</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – Interpolation method. Currently only ‘linear’ is supported. Defaults to ‘linear’.</p></li>
<li><p><strong>check_bounds</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to check if the interpolation times are within the path time bounds. Defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Interpolated Point object at the given times.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#astrix.spatial.Point" title="astrix.spatial.Point">Point</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Path.time_at_alt">
<span class="sig-name descname"><span class="pre">time_at_alt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alt</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Path.time_at_alt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Path.time_at_alt" title="Link to this definition">¶</a></dt>
<dd><p>Find the times when the Path crosses the given altitude (in metres).
Uses linear interpolation between points to find the crossing times.
Note: This function is not JIT-compatible due to data validation checks.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><code class="xref py py-class docutils literal notranslate"><span class="pre">Time</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>alt</strong> (<em>float</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Path.truncate">
<span class="sig-name descname"><span class="pre">truncate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Path.truncate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Path.truncate" title="Link to this definition">¶</a></dt>
<dd><p>Truncate the Path to the given start and end times.
If start_time or end_time is None, the Path is truncated to the start or end of the Path respectively.</p>
<p>Note: This function is not JIT-compatible due to data validation checks.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path" title="astrix.spatial.location.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul>
<li><p><strong>start_time</strong> (<a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><em>Time</em></a><em> | </em><em>None</em>)</p></li>
<li><p><strong>end_time</strong> (<a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><em>Time</em></a><em> | </em><em>None</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Path.acc">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">acc</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration" title="astrix.spatial.location.Acceleration"><span class="pre">Acceleration</span></a></span><a class="headerlink" href="#astrix.spatial.Path.acc" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the acceleration from the Path using central differences.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Path.end_time">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">end_time</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><span class="pre">Time</span></a></span><a class="headerlink" href="#astrix.spatial.Path.end_time" title="Link to this definition">¶</a></dt>
<dd><p>Get the end time of the Path.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Path.is_singular">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">is_singular</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></span><a class="headerlink" href="#astrix.spatial.Path.is_singular" title="Link to this definition">¶</a></dt>
<dd><p>Check if the Path object represents a single point.
Always False for Path objects.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Path.points">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">points</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point" title="astrix.spatial.location.Point"><span class="pre">Point</span></a></span><a class="headerlink" href="#astrix.spatial.Path.points" title="Link to this definition">¶</a></dt>
<dd><p>Get the list of Point objects that make up the Path.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Path.start_time">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">start_time</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><span class="pre">Time</span></a></span><a class="headerlink" href="#astrix.spatial.Path.start_time" title="Link to this definition">¶</a></dt>
<dd><p>Get the start time of the Path.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Path.vel">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">vel</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity" title="astrix.spatial.location.Velocity"><span class="pre">Velocity</span></a></span><a class="headerlink" href="#astrix.spatial.Path.vel" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the velocity from the Path using central differences.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="astrix.spatial.Point">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">Point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ecef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Time</span> <span class="pre">invariant</span> <span class="pre">(n=1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Point" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Location" title="astrix.spatial.location.Location"><code class="xref py py-class docutils literal notranslate"><span class="pre">Location</span></code></a></p>
<p>Point(s) in ECEF coordinates, stored as (x, y, z) in metres.
Can represent a single point or multiple points, and can be associated with
a Time object for time instances of the points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>ecef</strong> (<em>Array</em>) – ECEF coordinates as (x, y, z) in metres. Shape (3,) or (1,3) for single points, (n, 3) for multiple points.</p></li>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.html#astrix.Time" title="astrix.Time"><em>Time</em></a><em>, </em><em>optional</em>) – Time object associated with the points. If provided, the length of time must match the number of points.
Defaults to TIME_INVARIANT for static points.</p></li>
<li><p><strong>backend</strong> (<em>BackendArg</em><em>, </em><em>optional</em>) – Array backend to use (numpy, jax, etc.). Defaults to numpy.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Single static point:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">astrix</span><span class="w"> </span><span class="kn">import</span> <span class="n">Point</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">Point</span><span class="p">([</span><span class="o">-</span><span class="mf">5047162.4</span><span class="p">,</span> <span class="mf">2568329.79</span><span class="p">,</span> <span class="o">-</span><span class="mf">2924521.17</span><span class="p">])</span>  <span class="c1"># Brisbane ECEF (m)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span><span class="o">.</span><span class="n">geodet</span>  <span class="c1"># Convert to geodetic (lat, lon, alt)</span>
<span class="go">array([[-27.47, 153.03, 0.0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="n">from_geodet</span><span class="p">([</span><span class="o">-</span><span class="mf">27.47</span><span class="p">,</span> <span class="mf">153.03</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="o">.</span><span class="n">ecef</span>
<span class="go">array([[-5047162.4, 2568329.79, -2924521.17]])</span>
</pre></div>
</div>
<p>Multiple static points:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pts</span> <span class="o">=</span> <span class="n">Point</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mf">5047162.4</span><span class="p">,</span> <span class="mf">2568329.79</span><span class="p">,</span> <span class="o">-</span><span class="mf">2924521.17</span><span class="p">],</span>  <span class="c1"># Brisbane</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mf">2694045.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4293642.0</span><span class="p">,</span> <span class="mf">3857878.0</span><span class="p">],</span>  <span class="c1"># San Francisco</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pt_bris</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Dynamic point with time:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timezone</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">astrix</span><span class="w"> </span><span class="kn">import</span> <span class="n">Time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">Time</span><span class="o">.</span><span class="n">from_datetime</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">),</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pts_time</span> <span class="o">=</span> <span class="n">Point</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mf">5047162.4</span><span class="p">,</span> <span class="mf">2568329.79</span><span class="p">,</span> <span class="o">-</span><span class="mf">2924521.17</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="mf">2694045.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4293642.0</span><span class="p">,</span> <span class="mf">3857878.0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pts_time</span><span class="o">.</span><span class="n">has_time</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pts_time</span><span class="o">.</span><span class="n">is_singular</span>
<span class="go">False</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul>
<li><p>When associating a Time object, the length of the Time must match the number of points.</p></li>
<li><p>Use Path objects for interpolating between multiple points over time.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Point.from_geodet">
<span class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_geodet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geodet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Time</span> <span class="pre">invariant</span> <span class="pre">(n=1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Point.from_geodet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Point.from_geodet" title="Link to this definition">¶</a></dt>
<dd><p>Create a Point object from geodetic coordinates (lat, lon, alt).
Latitude and longitude are in degrees, altitude is in meters.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point" title="astrix.spatial.location.Point"><code class="xref py py-class docutils literal notranslate"><span class="pre">Point</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul>
<li><p><strong>geodet</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>)</p></li>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><em>Time</em></a>)</p></li>
<li><p><strong>backend</strong> (<em>str</em><em> | </em><em>Any</em><em> | </em><em>None</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Point.from_list">
<span class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Point.from_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Point.from_list" title="Link to this definition">¶</a></dt>
<dd><p>Create a Point object from a list of Point objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point" title="astrix.spatial.location.Point"><code class="xref py py-class docutils literal notranslate"><span class="pre">Point</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>points</strong> (<em>list</em><em>[</em><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point" title="astrix.spatial.location.Point"><em>Point</em></a><em>]</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Point.convert_to">
<span class="sig-name descname"><span class="pre">convert_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backend</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Point.convert_to"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Point.convert_to" title="Link to this definition">¶</a></dt>
<dd><p>Convert the Point object to a different backend.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point" title="astrix.spatial.location.Point"><code class="xref py py-class docutils literal notranslate"><span class="pre">Point</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>backend</strong> (<em>str</em><em> | </em><em>Any</em><em> | </em><em>None</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Point.has_time">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">has_time</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></span><a class="headerlink" href="#astrix.spatial.Point.has_time" title="Link to this definition">¶</a></dt>
<dd><p>Check if the Point has associated Time.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Point.is_singular">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">is_singular</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></span><a class="headerlink" href="#astrix.spatial.Point.is_singular" title="Link to this definition">¶</a></dt>
<dd><p>Check if the Point object represents a single point.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="astrix.spatial.Ray">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">Ray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dir_rel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin_rel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([[0.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">0.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">0.]])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Frame(name=ECEF</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_rot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">has_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(Time</span> <span class="pre">invariant</span> <span class="pre">(n=1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Time</span> <span class="pre">invariant</span> <span class="pre">(n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1))</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">numpy)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Time</span> <span class="pre">invariant</span> <span class="pre">(n=1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/ray.html#Ray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Ray" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A ray defined by an origin point, direction vector, reference frame, and optional time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>dir_rel</strong> (<em>Array</em>) – Nx3 array of ray direction vectors in local frame.
Need not be normalised. E.g., (1, 0, 0) is a ray pointing along axis 1 of reference frame.</p></li>
<li><p><strong>origin_rel</strong> (<em>Array</em>) – 1x3 or Nx3 array defining the ray origin(s) in local frame (meters).
Typically (0,0,0) for camera reference frames, or ECEF coordinates for ECEF frame rays.</p></li>
<li><p><strong>frame</strong> (<a class="reference internal" href="#astrix.spatial.Frame" title="astrix.spatial.Frame"><em>Frame</em></a><em>, </em><em>optional</em>) – Reference frame for the ray origin and direction.</p></li>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.html#astrix.Time" title="astrix.Time"><em>Time</em></a><em>, </em><em>optional</em>) – Time object associated with the rays.
Must be same length as origin if provided. Defaults to TIME_INVARIANT.</p></li>
<li><p><strong>check</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True (default), validate non-zero direction vectors; disable for JIT paths.</p></li>
<li><p><strong>backend</strong> (<em>BackendArg</em><em>, </em><em>optional</em>) – Array backend to use (numpy, jax, etc.). Defaults to numpy.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul>
<li><p>For calculating metrics (e.g. az/el), the axis are assumed (1) forward, (2) right, (3) down (FRD frame).</p></li>
<li><p>Although stored in local coordiantes, rays are globally defined by their reference frame.</p></li>
<li><dl class="simple">
<dt>Monotonically increasing time is required for interpolation. But to prevent data-dependent control flow,</dt><dd><p>this is not checked on initialization. Use Time.is_increasing to check if needed.</p>
</dd>
</dl>
</li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">astrix</span><span class="w"> </span><span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Ray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">origin</span> <span class="o">=</span> <span class="n">Point</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="n">Point</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ray</span> <span class="o">=</span> <span class="n">Ray</span><span class="o">.</span><span class="n">from_points</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ray</span><span class="o">.</span><span class="n">unit_rel</span>
<span class="go">array([[1., 0., 0.]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Ray.from_az_el">
<span class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_az_el</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">az_el</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Frame(name=ECEF</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_rot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">has_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(Time</span> <span class="pre">invariant</span> <span class="pre">(n=1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Time</span> <span class="pre">invariant</span> <span class="pre">(n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1))</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">numpy)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Time</span> <span class="pre">invariant</span> <span class="pre">(n=1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin_rel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([[0.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">0.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">0.]])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/ray.html#Ray.from_az_el"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Ray.from_az_el" title="Link to this definition">¶</a></dt>
<dd><p>Create a Ray object from origin points and heading/elevation angles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>az_el</strong> (<em>Array</em>) – Nx2 array of azimuth and elevation angles in degrees, relative to the reference frame.</p></li>
<li><p><strong>frame</strong> (<a class="reference internal" href="#astrix.spatial.Frame" title="astrix.spatial.Frame"><em>Frame</em></a><em>, </em><em>optional</em>) – Reference frame for the ray origin and direction.
Defaults to ECEF frame.</p></li>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.html#astrix.Time" title="astrix.Time"><em>Time</em></a><em>, </em><em>optional</em>) – Time object associated with the rays.</p></li>
<li><p><strong>origin_rel</strong> (<em>Array</em><em>, </em><em>optional</em>) – Nx3 array of ray origin points in local frame coordinates.
Defaults to (0,0,0), which is the reference frame origin.</p></li>
<li><p><strong>check</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to check input arrays for validity (not JIT compatible).
Defaults to True.</p></li>
<li><p><strong>backend</strong> (<em>BackendArg</em><em>, </em><em>optional</em>) – Array backend to use (numpy, jax, etc.). Defaults to numpy.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray" title="astrix.spatial.ray.Ray"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ray</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Ray.from_camera">
<span class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_camera</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pixel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">camera</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/ray.html#Ray.from_camera"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Ray.from_camera" title="Link to this definition">¶</a></dt>
<dd><p>Create a Ray object from pixel coordinates and a camera model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>pixel</strong> (<a class="reference internal" href="astrix.html#astrix.Pixel" title="astrix.Pixel"><em>Pixel</em></a>) – Pixel object defining the pixel coordinates and optional time.</p></li>
<li><p><strong>camera</strong> (<a class="reference internal" href="astrix.project.html#astrix.project.CameraLike" title="astrix.project.CameraLike"><em>CameraLike</em></a>) – Camera model defining the camera parameters and orientation.</p></li>
<li><p><strong>frame</strong> (<a class="reference internal" href="#astrix.spatial.Frame" title="astrix.spatial.Frame"><em>Frame</em></a>) – Reference frame for the ray origin and direction.</p></li>
<li><p><strong>backend</strong> (<em>BackendArg</em><em>, </em><em>optional</em>) – Array backend to use (numpy, jax, etc.). Defaults to numpy.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Ray object defined by the pixel coordinates and camera model.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#astrix.spatial.Ray" title="astrix.spatial.Ray">Ray</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Ray.from_points">
<span class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">endpoint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Time</span> <span class="pre">invariant</span> <span class="pre">(n=1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/ray.html#Ray.from_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Ray.from_points" title="Link to this definition">¶</a></dt>
<dd><p>Create a Ray object from origin and endpoint arrays in ECEF frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>endpoint</strong> (<a class="reference internal" href="#astrix.spatial.Point" title="astrix.spatial.Point"><em>Point</em></a>) – End points (ECEF coordinates). Must be length N.</p></li>
<li><p><strong>origin</strong> (<a class="reference internal" href="#astrix.spatial.Point" title="astrix.spatial.Point"><em>Point</em></a>) – Origin points (ECEF coordinates). Must be length N or 1.</p></li>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.html#astrix.Time" title="astrix.Time"><em>Time</em></a><em>, </em><em>optional</em>) – Time object associated with the rays. If TIME_INVARIANT,
time is inferred from endpoint or origin when available.</p></li>
<li><p><strong>check</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, validate geometry (non-zero directions).
Disable for JIT compatibility. Defaults to True.</p></li>
<li><p><strong>backend</strong> (<em>BackendArg</em><em>, </em><em>optional</em>) – Array backend to use (numpy, jax, etc.). Defaults to numpy.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Ray object defined by the origin and direction from origin to endpoint.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#astrix.spatial.Ray" title="astrix.spatial.Ray">Ray</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Ray.from_target_frame">
<span class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_target_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/ray.html#Ray.from_target_frame"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Ray.from_target_frame" title="Link to this definition">¶</a></dt>
<dd><p>Create a Ray object from a reference frame and target point(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>target</strong> (<a class="reference internal" href="#astrix.spatial.Point" title="astrix.spatial.Point"><em>Point</em></a>) – Target point(s) in ECEF coordinates. Must be length N or 1.</p></li>
<li><p><strong>frame</strong> (<a class="reference internal" href="#astrix.spatial.Frame" title="astrix.spatial.Frame"><em>Frame</em></a>) – Reference frame for the ray origin and direction.</p></li>
<li><p><strong>check_bounds</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, ensure target times fall within frame time ranges.</p></li>
<li><p><strong>backend</strong> (<em>BackendArg</em><em>, </em><em>optional</em>) – Array backend to use (numpy, jax, etc.). Defaults to numpy.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Ray object defined by the frame origin and direction to the target point(s).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#astrix.spatial.Ray" title="astrix.spatial.Ray">Ray</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Ray.convert_to">
<span class="sig-name descname"><span class="pre">convert_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backend</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/ray.html#Ray.convert_to"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Ray.convert_to" title="Link to this definition">¶</a></dt>
<dd><p>Convert the Ray object to a different backend.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray" title="astrix.spatial.ray.Ray"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ray</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>backend</strong> (<em>str</em><em> | </em><em>Any</em><em> | </em><em>None</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Ray.correct_refraction">
<span class="sig-name descname"><span class="pre">correct_refraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/ray.html#Ray.correct_refraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Ray.correct_refraction" title="Link to this definition">¶</a></dt>
<dd><p>Apply atmospheric refraction correction to the Ray object using Bennett’s formula.
Altitude sets the exponential scale height (metres) for the correction.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>New Ray object with refraction-corrected direction vectors.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#astrix.spatial.Ray" title="astrix.spatial.Ray">Ray</a></p>
</dd>
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>alt</strong> (<em>float</em>)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul>
<li><p>Assumes standard atmospheric conditions.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Ray.interp">
<span class="sig-name descname"><span class="pre">interp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/ray.html#Ray.interp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Ray.interp" title="Link to this definition">¶</a></dt>
<dd><p>Interpolate the Ray origin and direction to the given times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.html#astrix.Time" title="astrix.Time"><em>Time</em></a>) – Times to interpolate to.</p></li>
<li><p><strong>check_bounds</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to check if the interpolation
times are within the ray time bounds. Defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Interpolated Ray object at the given times.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#astrix.spatial.Ray" title="astrix.spatial.Ray">Ray</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Ray.project_to_cam">
<span class="sig-name descname"><span class="pre">project_to_cam</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">camera</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/ray.html#Ray.project_to_cam"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Ray.project_to_cam" title="Link to this definition">¶</a></dt>
<dd><p>Project the Ray object to pixel coordinates using a camera model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>camera</strong> (<a class="reference internal" href="astrix.project.html#astrix.project.CameraLike" title="astrix.project.CameraLike"><em>CameraLike</em></a>) – Camera model defining the camera parameters and orientation.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Pixel object defining the pixel coordinates and associated time.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="astrix.html#astrix.Pixel" title="astrix.Pixel">Pixel</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul>
<li><p>The Ray must be defined in the same reference frame as the camera.</p></li>
<li><p>Rays that do not intersect the image plane will result in NaN pixel coordinates.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Ray.replace_frame">
<span class="sig-name descname"><span class="pre">replace_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/ray.html#Ray.replace_frame"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Ray.replace_frame" title="Link to this definition">¶</a></dt>
<dd><p>Replace the reference frame of the Ray without changing origin or direction.
Not a transformation, but direct replacement. Use with caution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>frame</strong> (<a class="reference internal" href="#astrix.spatial.Frame" title="astrix.spatial.Frame"><em>Frame</em></a>) – New reference frame for the ray.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Ray object with the new reference frame.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#astrix.spatial.Ray" title="astrix.spatial.Ray">Ray</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Ray.to_ecef">
<span class="sig-name descname"><span class="pre">to_ecef</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/ray.html#Ray.to_ecef"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Ray.to_ecef" title="Link to this definition">¶</a></dt>
<dd><p>Convert the Ray object to ECEF coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray" title="astrix.spatial.ray.Ray"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ray</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Ray.to_frame">
<span class="sig-name descname"><span class="pre">to_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/ray.html#Ray.to_frame"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Ray.to_frame" title="Link to this definition">¶</a></dt>
<dd><p>Convert the Ray object to a different reference frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>frame</strong> (<a class="reference internal" href="#astrix.spatial.Frame" title="astrix.spatial.Frame"><em>Frame</em></a>) – Reference frame to convert the ray to.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Ray object defined in the new reference frame.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#astrix.spatial.Ray" title="astrix.spatial.Ray">Ray</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Ray.to_ned">
<span class="sig-name descname"><span class="pre">to_ned</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/ray.html#Ray.to_ned"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Ray.to_ned" title="Link to this definition">¶</a></dt>
<dd><p>Convert the Ray object to a local NED frame at the ray origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray" title="astrix.spatial.ray.Ray"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ray</span></code></a></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Ray.az_el">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">az_el</span></span><a class="headerlink" href="#astrix.spatial.Ray.az_el" title="Link to this definition">¶</a></dt>
<dd><p>Return the azimuth and elevation angles from the forward axis in degrees.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Ray.backend">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">backend</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">str</span></span><a class="headerlink" href="#astrix.spatial.Ray.backend" title="Link to this definition">¶</a></dt>
<dd><p>Get the name of the array backend in use (e.g., ‘numpy’, ‘jax’).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Ray.frame">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">frame</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame" title="astrix.spatial.frame.Frame"><span class="pre">Frame</span></a></span><a class="headerlink" href="#astrix.spatial.Ray.frame" title="Link to this definition">¶</a></dt>
<dd><p>Get the reference Frame of the ray.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Ray.has_time">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">has_time</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></span><a class="headerlink" href="#astrix.spatial.Ray.has_time" title="Link to this definition">¶</a></dt>
<dd><p>Check if the Ray has associated Time.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Ray.origin_points">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">origin_points</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point" title="astrix.spatial.location.Point"><span class="pre">Point</span></a></span><a class="headerlink" href="#astrix.spatial.Ray.origin_points" title="Link to this definition">¶</a></dt>
<dd><p>Get the ray origin point(s) as ECEF.
Note: this involves a frame transformation. For repeated access,
recommend converting the Ray to ECEF frame first using to_ecef().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Ray.origin_rel">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">origin_rel</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Any</span></span><a class="headerlink" href="#astrix.spatial.Ray.origin_rel" title="Link to this definition">¶</a></dt>
<dd><p>Get the ray origin point(s) in the local frame coordinates.
Typically zero for camera reference frames, or ECEF coordinates for ECEF frame rays.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Ray.time">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">time</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><span class="pre">Time</span></a></span><a class="headerlink" href="#astrix.spatial.Ray.time" title="Link to this definition">¶</a></dt>
<dd><p>Get the associated Time object, if any.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Ray.total_angle">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">total_angle</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Any</span></span><a class="headerlink" href="#astrix.spatial.Ray.total_angle" title="Link to this definition">¶</a></dt>
<dd><p>Return the total angle from the forward axis in degrees.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Ray.unit_ecef">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">unit_ecef</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Any</span></span><a class="headerlink" href="#astrix.spatial.Ray.unit_ecef" title="Link to this definition">¶</a></dt>
<dd><p>Get the unit direction vector(s) of the ray in ECEF frame.
Note: this involves a frame transformation. For repeated access,
recommend converting the Ray to ECEF frame first using to_ecef().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Ray.unit_rel">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">unit_rel</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Any</span></span><a class="headerlink" href="#astrix.spatial.Ray.unit_rel" title="Link to this definition">¶</a></dt>
<dd><p>Get the unit direction vector(s) of the ray in the local frame coordinates.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="astrix.spatial.Rotation">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">Rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar_first</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Rotation in 3 dimensions.</p>
<p>This class provides an interface to initialize from and represent rotations
with:</p>
<ul>
<li><p>Quaternions</p></li>
<li><p>Rotation Matrices</p></li>
<li><p>Rotation Vectors</p></li>
<li><p>Modified Rodrigues Parameters</p></li>
<li><p>Euler Angles</p></li>
<li><p>Davenport Angles (Generalized Euler Angles)</p></li>
</ul>
<p>The following operations on rotations are supported:</p>
<ul>
<li><p>Application on vectors</p></li>
<li><p>Rotation Composition</p></li>
<li><p>Rotation Inversion</p></li>
<li><p>Rotation Indexing</p></li>
</ul>
<p>A <cite>Rotation</cite> instance can contain a single rotation transform or rotations of
multiple leading dimensions. E.g., it is possible to have an N-dimensional array of
(N, M, K) rotations. When applied to other rotations or vectors, standard
broadcasting rules apply.</p>
<p>Indexing within a rotation is supported to access a subset of the rotations stored
in a <cite>Rotation</cite> instance.</p>
<p>To create <cite>Rotation</cite> objects use <code class="docutils literal notranslate"><span class="pre">from_...</span></code> methods (see examples below).
<code class="docutils literal notranslate"><span class="pre">Rotation(...)</span></code> is not supposed to be instantiated directly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>quat</strong> (<em>ArrayLike</em>)</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>)</p></li>
<li><p><strong>copy</strong> (<em>bool</em>)</p></li>
<li><p><strong>scalar_first</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.single">
<span class="sig-name descname"><span class="pre">single</span></span><a class="headerlink" href="#astrix.spatial.Rotation.single" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.__len__">
<span class="sig-name descname"><span class="pre">__len__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.__len__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.__len__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.from_quat">
<span class="sig-name descname"><span class="pre">from_quat</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.from_quat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.from_quat" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>quat</strong> (<em>Any</em><em> | </em><em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>)</p></li>
<li><p><strong>scalar_first</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.from_matrix">
<span class="sig-name descname"><span class="pre">from_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.from_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.from_matrix" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>matrix</strong> (<em>Any</em><em> | </em><em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>)</p></li>
<li><p><strong>assume_valid</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.from_rotvec">
<span class="sig-name descname"><span class="pre">from_rotvec</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.from_rotvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.from_rotvec" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>rotvec</strong> (<em>Any</em><em> | </em><em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>)</p></li>
<li><p><strong>degrees</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.from_mrp">
<span class="sig-name descname"><span class="pre">from_mrp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.from_mrp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.from_mrp" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mrp</strong> (<em>Any</em><em> | </em><em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.from_euler">
<span class="sig-name descname"><span class="pre">from_euler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.from_euler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.from_euler" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>seq</strong> (<em>str</em>)</p></li>
<li><p><strong>angles</strong> (<em>Any</em><em> | </em><em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>)</p></li>
<li><p><strong>degrees</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.from_davenport">
<span class="sig-name descname"><span class="pre">from_davenport</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.from_davenport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.from_davenport" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>axes</strong> (<em>Any</em><em> | </em><em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>)</p></li>
<li><p><strong>order</strong> (<em>str</em>)</p></li>
<li><p><strong>angles</strong> (<em>Any</em><em> | </em><em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>] </em><em>| </em><em>float</em>)</p></li>
<li><p><strong>degrees</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.as_quat">
<span class="sig-name descname"><span class="pre">as_quat</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.as_quat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.as_quat" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>canonical</strong> (<em>bool</em>)</p></li>
<li><p><strong>scalar_first</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Any</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.as_matrix">
<span class="sig-name descname"><span class="pre">as_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.as_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.as_matrix" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Any</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.as_rotvec">
<span class="sig-name descname"><span class="pre">as_rotvec</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.as_rotvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.as_rotvec" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>degrees</strong> (<em>bool</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Any</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.as_mrp">
<span class="sig-name descname"><span class="pre">as_mrp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.as_mrp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.as_mrp" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Any</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.as_euler">
<span class="sig-name descname"><span class="pre">as_euler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.as_euler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.as_euler" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>seq</strong> (<em>str</em>)</p></li>
<li><p><strong>degrees</strong> (<em>bool</em>)</p></li>
<li><p><strong>suppress_warnings</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Any</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.as_davenport">
<span class="sig-name descname"><span class="pre">as_davenport</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.as_davenport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.as_davenport" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>axes</strong> (<em>Any</em><em> | </em><em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>)</p></li>
<li><p><strong>order</strong> (<em>str</em>)</p></li>
<li><p><strong>degrees</strong> (<em>bool</em>)</p></li>
<li><p><strong>suppress_warnings</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Any</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.concatenate">
<span class="sig-name descname"><span class="pre">concatenate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.concatenate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.concatenate" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rotations</strong> (<a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a><em> | </em><em>Iterable</em><em>[</em><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a><em>]</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.apply" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>vectors</strong> (<em>Any</em><em> | </em><em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>)</p></li>
<li><p><strong>inverse</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Any</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.__mul__">
<span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.__mul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.__mul__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.__pow__">
<span class="sig-name descname"><span class="pre">__pow__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.__pow__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.__pow__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.inv">
<span class="sig-name descname"><span class="pre">inv</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.inv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.inv" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.magnitude">
<span class="sig-name descname"><span class="pre">magnitude</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.magnitude"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.magnitude" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Any</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.approx_equal">
<span class="sig-name descname"><span class="pre">approx_equal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.approx_equal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.approx_equal" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>other</strong> (<a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a>)</p></li>
<li><p><strong>atol</strong> (<em>float</em><em> | </em><em>None</em>)</p></li>
<li><p><strong>degrees</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Any</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.mean">
<span class="sig-name descname"><span class="pre">mean</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.mean" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>weights</strong> (<em>Any</em><em> | </em><em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>] </em><em>| </em><em>None</em>)</p></li>
<li><p><strong>axis</strong> (<em>None</em><em> | </em><em>int</em><em> | </em><em>tuple</em><em>[</em><em>int</em><em>, </em><em>...</em><em>]</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.reduce">
<span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.reduce"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.reduce" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>left</strong> (<a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a><em> | </em><em>None</em>)</p></li>
<li><p><strong>right</strong> (<a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a><em> | </em><em>None</em>)</p></li>
<li><p><strong>return_indices</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a> | tuple[<a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a>, <em>Any</em>, <em>Any</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.create_group">
<span class="sig-name descname"><span class="pre">create_group</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.create_group"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.create_group" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>group</strong> (<em>str</em>)</p></li>
<li><p><strong>axis</strong> (<em>str</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.__getitem__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.__getitem__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.identity">
<span class="sig-name descname"><span class="pre">identity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.identity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.identity" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>num</strong> (<em>int</em><em> | </em><em>None</em>)</p></li>
<li><p><strong>shape</strong> (<em>int</em><em> | </em><em>tuple</em><em>[</em><em>int</em><em>, </em><em>...</em><em>] </em><em>| </em><em>None</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.random">
<span class="sig-name descname"><span class="pre">random</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.random"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.random" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>num</strong> (<em>int</em><em> | </em><em>None</em>)</p></li>
<li><p><strong>rng</strong> (<em>Generator</em><em> | </em><em>None</em>)</p></li>
<li><p><strong>shape</strong> (<em>tuple</em><em>[</em><em>int</em><em>, </em><em>...</em><em>] </em><em>| </em><em>None</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.align_vectors">
<span class="sig-name descname"><span class="pre">align_vectors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.align_vectors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Rotation.align_vectors" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>a</strong> (<em>Any</em><em> | </em><em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>)</p></li>
<li><p><strong>b</strong> (<em>Any</em><em> | </em><em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>)</p></li>
<li><p><strong>weights</strong> (<em>Any</em><em> | </em><em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>] </em><em>| </em><em>None</em>)</p></li>
<li><p><strong>return_sensitivity</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[<a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a>, float] | tuple[<a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a>, float, <em>Any</em>]</p>
</dd>
</dl>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Slerp</span></code></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 1.2.0.</span></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
</pre></div>
</div>
<p>A <cite>Rotation</cite> instance can be initialized in any of the above formats and
converted to any of the others. The underlying object is independent of the
representation used for initialization.</p>
<p>Consider a counter-clockwise rotation of 90 degrees about the z-axis. This
corresponds to the following quaternion (in scalar-last format):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_quat</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)])</span>
</pre></div>
</div>
<p>The rotation can be expressed in any of the other formats:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="go">[ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="go">[ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="go">array([0.        , 0.        , 1.57079633])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([90.,  0.,  0.])</span>
</pre></div>
</div>
<p>The same rotation can be initialized using a rotation matrix:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<p>Representation in other formats:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>
<span class="go">array([0.        , 0.        , 0.70710678, 0.70710678])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="go">array([0.        , 0.        , 1.57079633])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([90.,  0.,  0.])</span>
</pre></div>
</div>
<p>The rotation vector corresponding to this rotation is given by:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>Representation in other formats:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>
<span class="go">array([0.        , 0.        , 0.70710678, 0.70710678])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="go">       [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="go">       [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([90.,  0.,  0.])</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">from_euler</span></code> method is quite flexible in the range of input formats
it supports. Here we initialize a single rotation about a single axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Again, the object is representation independent and can be converted to any
other format:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>
<span class="go">array([0.        , 0.        , 0.70710678, 0.70710678])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="go">       [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="go">       [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="go">array([0.        , 0.        , 1.57079633])</span>
</pre></div>
</div>
<p>It is also possible to initialize multiple rotations in a single instance
using any of the <code class="docutils literal notranslate"><span class="pre">from_...</span></code> functions. Here we initialize a stack of 3
rotations using the <code class="docutils literal notranslate"><span class="pre">from_euler</span></code> method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="p">[</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">30</span><span class="p">]],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The other representations also now return a stack of 3 rotations. For
example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>
<span class="go">array([[0.        , 0.        , 0.70710678, 0.70710678],</span>
<span class="go">       [0.        , 0.38268343, 0.        , 0.92387953],</span>
<span class="go">       [0.39190384, 0.36042341, 0.43967974, 0.72331741]])</span>
</pre></div>
</div>
<p>Applying the above rotations onto a vector:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">array([[-2.        ,  1.        ,  3.        ],</span>
<span class="go">       [ 2.82842712,  2.        ,  1.41421356],</span>
<span class="go">       [ 2.24452282,  0.78093109,  2.89002836]])</span>
</pre></div>
</div>
<p>A <cite>Rotation</cite> instance can be indexed and sliced as if it were an ND array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>
<span class="go">array([[0.        , 0.        , 0.70710678, 0.70710678],</span>
<span class="go">       [0.        , 0.38268343, 0.        , 0.92387953],</span>
<span class="go">       [0.39190384, 0.36042341, 0.43967974, 0.72331741]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="go">       [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="go">       [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>
<span class="go">array([[0.        , 0.38268343, 0.        , 0.92387953],</span>
<span class="go">       [0.39190384, 0.36042341, 0.43967974, 0.72331741]])</span>
</pre></div>
</div>
<p>In fact it can be converted to numpy.array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r_array</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="go">       [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="go">       [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])</span>
</pre></div>
</div>
<p>Multiple rotations can be composed using the <code class="docutils literal notranslate"><span class="pre">*</span></code> operator:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">r1</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="go">array([-2.        , -1.41421356,  2.82842712])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r3</span> <span class="o">=</span> <span class="n">r2</span> <span class="o">*</span> <span class="n">r1</span> <span class="c1"># Note the order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r3</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">array([-2.        , -1.41421356,  2.82842712])</span>
</pre></div>
</div>
<p>A rotation can be composed with itself using the <code class="docutils literal notranslate"><span class="pre">**</span></code> operator:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span> <span class="o">**</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="go">array([2., 0., 0.])</span>
</pre></div>
</div>
<p>Finally, it is also possible to invert rotations:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">90</span><span class="p">],</span> <span class="p">[</span><span class="mi">45</span><span class="p">]],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[-90.,   0.,   0.],</span>
<span class="go">       [-45.,   0.,   0.]])</span>
</pre></div>
</div>
<p>The following function can be used to plot rotations with Matplotlib by
showing how they transform the standard x, y, z coordinate axes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">plot_rotated_axes</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">colors</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;#FF6666&quot;</span><span class="p">,</span> <span class="s2">&quot;#005533&quot;</span><span class="p">,</span> <span class="s2">&quot;#1199EE&quot;</span><span class="p">)</span>  <span class="c1"># Colorblind-safe RGB</span>
<span class="gp">... </span>    <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">((</span><span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">zaxis</span><span class="p">),</span>
<span class="gp">... </span>                                      <span class="n">colors</span><span class="p">)):</span>
<span class="gp">... </span>        <span class="n">axlabel</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">axis_name</span>
<span class="gp">... </span>        <span class="n">axis</span><span class="o">.</span><span class="n">set_label_text</span><span class="p">(</span><span class="n">axlabel</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">axis</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">axis</span><span class="o">.</span><span class="n">line</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">axis</span><span class="o">.</span><span class="n">set_tick_params</span><span class="p">(</span><span class="n">colors</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">... </span>        <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span>
<span class="gp">... </span>        <span class="n">line_rot</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">line_plot</span> <span class="o">=</span> <span class="n">line_rot</span> <span class="o">+</span> <span class="n">loc</span>
<span class="gp">... </span>        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">line_plot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">line_plot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">line_plot</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">text_loc</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">1.2</span>
<span class="gp">... </span>        <span class="n">text_loc_rot</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">text_loc</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">text_plot</span> <span class="o">=</span> <span class="n">text_loc_rot</span> <span class="o">+</span> <span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="o">*</span><span class="n">text_plot</span><span class="p">,</span> <span class="n">axlabel</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">bbox</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fc&quot;</span><span class="p">:</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">,</span> <span class="s2">&quot;boxstyle&quot;</span><span class="p">:</span> <span class="s2">&quot;circle&quot;</span><span class="p">})</span>
</pre></div>
</div>
<p>Create three rotations - the identity and two Euler rotations using
intrinsic and extrinsic conventions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r0</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s2">&quot;ZYX&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># intrinsic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s2">&quot;zyx&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># extrinsic</span>
</pre></div>
</div>
<p>Add all three rotations to a single plot:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">,</span> <span class="n">proj_type</span><span class="o">=</span><span class="s2">&quot;ortho&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_rotated_axes</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;r0&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_rotated_axes</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;r1&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot_rotated_axes</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;r2&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;r0: Identity Rotation</span><span class="se">\n</span><span class="s2">&quot;</span>
<span class="gp">... </span>    <span class="s2">&quot;r1: Intrinsic Euler Rotation (ZYX)</span><span class="se">\n</span><span class="s2">&quot;</span>
<span class="gp">... </span>    <span class="s2">&quot;r2: Extrinsic Euler Rotation (zyx)&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">),</span> <span class="n">xycoords</span><span class="o">=</span><span class="s2">&quot;axes fraction&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.25</span><span class="p">,</span> <span class="mf">7.25</span><span class="p">),</span> <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.25</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">),</span> <span class="n">zlim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.25</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xticks</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">yticks</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">zticks</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">,</span> <span class="n">adjustable</span><span class="o">=</span><span class="s2">&quot;box&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
<p>Show the plot:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>These examples serve as an overview into the <cite>Rotation</cite> class and highlight
major functionalities. For more thorough examples of the range of input and
output formats supported, consult the individual method’s examples.</p>
<dl class="py method">
<dt class="sig sig-object py" id="id0">
<span class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">create_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Z'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.create_group"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Link to this definition">¶</a></dt>
<dd><p>Create a 3D rotation group.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>group</strong> (<em>string</em>) – <p>The name of the group. Must be one of ‘I’, ‘O’, ‘T’, ‘Dn’, ‘Cn’,
where <cite>n</cite> is a positive integer. The groups are:</p>
<blockquote>
<div><ul>
<li><p>I: Icosahedral group</p></li>
<li><p>O: Octahedral group</p></li>
<li><p>T: Tetrahedral group</p></li>
<li><p>D: Dicyclic group</p></li>
<li><p>C: Cyclic group</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>axis</strong> (<em>integer</em>) – The cyclic rotation axis. Must be one of [‘X’, ‘Y’, ‘Z’] (or
lowercase). Default is ‘Z’. Ignored for groups ‘I’, ‘O’, and ‘T’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rotation</strong> – Object containing the elements of the rotation group.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>Rotation</cite> instance</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method generates rotation groups only. The full 3-dimensional
point groups <a class="reference internal" href="#pointgroups" id="id1"><span>[PointGroups]</span></a> also contain reflections.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="pointgroups" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">PointGroups</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Point_groups_in_three_dimensions">Point groups</a>
on Wikipedia.</p>
</div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id2">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">align_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_sensitivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.align_vectors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id2" title="Link to this definition">¶</a></dt>
<dd><p>Estimate a rotation to optimally align two sets of vectors.</p>
<p>Find a rotation between frames A and B which best aligns a set of
vectors <cite>a</cite> and <cite>b</cite> observed in these frames. The following loss
function is minimized to solve for the rotation matrix
<span class="math notranslate nohighlight">\(C\)</span>:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[L(C) = \frac{1}{2} \sum_{i = 1}^{n} w_i \lVert \mathbf{a}_i -
C \mathbf{b}_i \rVert^2 ,\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(w_i\)</span>’s are the <cite>weights</cite> corresponding to each vector.</p>
<p>The rotation is estimated with Kabsch algorithm <a href="#id80"><span class="problematic" id="id3">[1]_</span></a>, and solves what
is known as the “pointing problem”, or “Wahba’s problem” <a href="#id81"><span class="problematic" id="id4">[2]_</span></a>.</p>
<p>Note that the length of each vector in this formulation acts as an
implicit weight. So for use cases where all vectors need to be
weighted equally, you should normalize them to unit length prior to
calling this method.</p>
<p>There are two special cases. The first is if a single vector is given
for <cite>a</cite> and <cite>b</cite>, in which the shortest distance rotation that aligns
<cite>b</cite> to <cite>a</cite> is returned.</p>
<p>The second is when one of the weights is infinity. In this case, the
shortest distance rotation between the primary infinite weight vectors
is calculated as above. Then, the rotation about the aligned primary
vectors is calculated such that the secondary vectors are optimally
aligned per the above loss function. The result is the composition
of these two rotations. The result via this process is the same as the
Kabsch algorithm as the corresponding weight approaches infinity in
the limit. For a single secondary vector this is known as the
“align-constrain” algorithm <a href="#id82"><span class="problematic" id="id5">[3]_</span></a>.</p>
<p>For both special cases (single vectors or an infinite weight), the
sensitivity matrix does not have physical meaning and an error will be
raised if it is requested. For an infinite weight, the primary vectors
act as a constraint with perfect alignment, so their contribution to
<cite>rssd</cite> will be forced to 0 even if they are of different lengths.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>a</strong> (<em>array_like</em><em>, </em><a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape"><em>shape</em></a><em> (</em><em>3</em><em>,</em><em>) or </em><em>(</em><em>N</em><em>, </em><em>3</em><em>)</em>) – Vector components observed in initial frame A. Each row of <cite>a</cite>
denotes a vector.</p></li>
<li><p><strong>b</strong> (<em>array_like</em><em>, </em><a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape"><em>shape</em></a><em> (</em><em>3</em><em>,</em><em>) or </em><em>(</em><em>N</em><em>, </em><em>3</em><em>)</em>) – Vector components observed in another frame B. Each row of <cite>b</cite>
denotes a vector.</p></li>
<li><p><strong>weights</strong> (<em>array_like shape</em><em> (</em><em>N</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Weights describing the relative importance of the vector
observations. If None (default), then all values in <cite>weights</cite> are
assumed to be 1. One and only one weight may be infinity, and
weights must be positive.</p></li>
<li><p><strong>return_sensitivity</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the sensitivity matrix. See Notes for details.
Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>] | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul>
<li><p><strong>rotation</strong> (<cite>Rotation</cite> instance) – Best estimate of the rotation that transforms <cite>b</cite> to <cite>a</cite>.</p></li>
<li><p><strong>rssd</strong> (<em>float</em>) – Stands for “root sum squared distance”. Square root of the weighted
sum of the squared distances between the given sets of vectors
after alignment. It is equal to <code class="docutils literal notranslate"><span class="pre">sqrt(2</span> <span class="pre">*</span> <span class="pre">minimum_loss)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">minimum_loss</span></code> is the loss function evaluated for the found
optimal rotation.
Note that the result will also be weighted by the vectors’
magnitudes, so perfectly aligned vector pairs will have nonzero
<cite>rssd</cite> if they are not of the same length. This can be avoided by
normalizing them to unit length prior to calling this method,
though note that doing this will change the resulting rotation.</p></li>
<li><p><strong>sensitivity_matrix</strong> (<em>ndarray, shape (3, 3)</em>) – Sensitivity matrix of the estimated rotation estimate as explained
in Notes. Returned only when <cite>return_sensitivity</cite> is True. Not
valid if aligning a single pair of vectors or if there is an
infinite weight, in which cases an error will be raised.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The sensitivity matrix gives the sensitivity of the estimated rotation
to small perturbations of the vector measurements. Specifically we
consider the rotation estimate error as a small rotation vector of
frame A. The sensitivity matrix is proportional to the covariance of
this rotation vector assuming that the vectors in <cite>a</cite> was measured with
errors significantly less than their lengths. To get the true
covariance matrix, the returned sensitivity matrix must be multiplied
by harmonic mean <a class="footnote-reference brackets" href="#id12" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> of variance in each observation. Note that
<cite>weights</cite> are supposed to be inversely proportional to the observation
variances to get consistent results. For example, if all vectors are
measured with the same accuracy of 0.01 (<cite>weights</cite> must be all equal),
then you should multiple the sensitivity matrix by 0.01**2 to get the
covariance.</p>
<p>Refer to <a class="footnote-reference brackets" href="#id13" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> for more rigorous discussion of the covariance
estimation. See <a class="footnote-reference brackets" href="#id14" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> for more discussion of the pointing problem and
minimal proper pointing.</p>
<p>This function does not support broadcasting or ND arrays with N &gt; 2.</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>align_vectors</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>⛔</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Kabsch_algorithm">https://en.wikipedia.org/wiki/Kabsch_algorithm</a></p>
</aside>
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Wahba%27s_problem">https://en.wikipedia.org/wiki/Wahba%27s_problem</a></p>
</aside>
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Magner, Robert,
“Extending target tracking capabilities through trajectory and
momentum setpoint optimization.” Small Satellite Conference,
2018.</p>
</aside>
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Harmonic_mean">https://en.wikipedia.org/wiki/Harmonic_mean</a></p>
</aside>
<aside class="footnote brackets" id="id13" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">5</a><span class="fn-bracket">]</span></span>
<p>F. Landis Markley,
“Attitude determination using vector observations: a fast
optimal matrix algorithm”, Journal of Astronautical Sciences,
Vol. 41, No.2, 1993, pp. 261-280.</p>
</aside>
<aside class="footnote brackets" id="id14" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">6</a><span class="fn-bracket">]</span></span>
<p>Bar-Itzhack, Itzhack Y., Daniel Hershkowitz, and Leiba Rodman,
“Pointing in Real Euclidean Space”, Journal of Guidance,
Control, and Dynamics, Vol. 20, No. 5, 1997, pp. 916-922.</p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
</pre></div>
</div>
<p>Here we run the baseline Kabsch algorithm to best align two sets of
vectors, where there is noise on the last two vector measurements of
the <code class="docutils literal notranslate"><span class="pre">b</span></code> set:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot</span><span class="p">,</span> <span class="n">rssd</span><span class="p">,</span> <span class="n">sens</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">align_vectors</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">return_sensitivity</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[0., 0., 1.],</span>
<span class="go">       [1., 0., 0.],</span>
<span class="go">       [0., 1., 0.]])</span>
</pre></div>
</div>
<p>When we apply the rotation to <code class="docutils literal notranslate"><span class="pre">b</span></code>, we get vectors close to <code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rot</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([[0. , 1. , 0. ],</span>
<span class="go">       [0. , 1. , 1.1],</span>
<span class="go">       [0. , 1. , 0.9]])</span>
</pre></div>
</div>
<p>The error for the first vector is 0, and for the last two the error is
magnitude 0.1. The <cite>rssd</cite> is the square root of the sum of the
weighted squared errors, and the default weights are all 1, so in this
case the <cite>rssd</cite> is calculated as
<code class="docutils literal notranslate"><span class="pre">sqrt(1</span> <span class="pre">*</span> <span class="pre">0**2</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">*</span> <span class="pre">0.1**2</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">*</span> <span class="pre">(-0.1)**2)</span> <span class="pre">=</span> <span class="pre">0.141421356237308</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-</span> <span class="n">rot</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([[ 0., 0.,  0. ],</span>
<span class="go">       [ 0., 0., -0.1],</span>
<span class="go">       [ 0., 0.,  0.1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">rot</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="go">0.141421356237308</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rssd</span>
<span class="go">0.141421356237308</span>
</pre></div>
</div>
<p>The sensitivity matrix for this example is as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sens</span>
<span class="go">array([[0.2, 0. , 0.],</span>
<span class="go">       [0. , 1.5, 1.],</span>
<span class="go">       [0. , 1. , 1.]])</span>
</pre></div>
</div>
<p>Special case 1: Find a minimum rotation between single vectors:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">align_vectors</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[0., 1., 0.],</span>
<span class="go">       [-1., 0., 0.],</span>
<span class="go">       [0., 0., 1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([1., 0., 0.])</span>
</pre></div>
</div>
<p>Special case 2: One infinite weight. Here we find a rotation between
primary and secondary vectors that can align exactly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">align_vectors</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[0., 0., 1.],</span>
<span class="go">       [1., 0., 0.],</span>
<span class="go">       [0., 1., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([[0., 1., 0.],</span>
<span class="go">       [0., 1., 1.]])</span>
</pre></div>
</div>
<p>Here the secondary vectors must be best-fit:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">align_vectors</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[0., 0., 1.],</span>
<span class="go">       [1., 0., 0.],</span>
<span class="go">       [0., 1., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">array([[0., 1., 0.],</span>
<span class="go">       [0., 1., 2.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id15">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">concatenate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotations</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.concatenate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id15" title="Link to this definition">¶</a></dt>
<dd><p>Concatenate a sequence of <cite>Rotation</cite> objects into a single object.</p>
<p>This is useful if you want to, for example, take the mean of a set of
rotations and need to pack them into a single object to do so.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rotations</strong> (sequence of <cite>Rotation</cite> objects) – The rotations to concatenate. If a single <cite>Rotation</cite> object is
passed in, a copy is returned.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>concatenated</strong> – The concatenated rotations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>Rotation</cite> instance</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 1.8.0.</span></p>
</div>
<p><strong>Array API Standard Support</strong></p>
<p><cite>concatenate</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="go">array([[0., 0., 1.],</span>
<span class="go">       [0., 0., 2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="go">array([0., 0., 1.5])</span>
</pre></div>
</div>
<p>Concatenation of a split rotation recovers the original object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rs</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rc</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="go">array([[0., 0., 1.],</span>
<span class="go">       [0., 0., 2.]])</span>
</pre></div>
</div>
<p>Note that it may be simpler to create the desired rotations by passing
in a single list of the data during initialization, rather then by
concatenating:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="go">array([[0., 0., 1.],</span>
<span class="go">       [0., 0., 2.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id16">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_davenport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.from_davenport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id16" title="Link to this definition">¶</a></dt>
<dd><p>Initialize from Davenport angles.</p>
<p>Rotations in 3-D can be represented by a sequence of 3
rotations around a sequence of axes.</p>
<p>The three rotations can either be in a global frame of reference
(extrinsic) or in a body centred frame of reference (intrinsic), which
is attached to, and moves with, the object under rotation <a href="#id83"><span class="problematic" id="id17">[1]_</span></a>.</p>
<p>For both Euler angles and Davenport angles, consecutive axes must
be are orthogonal (<code class="docutils literal notranslate"><span class="pre">axis2</span></code> is orthogonal to both <code class="docutils literal notranslate"><span class="pre">axis1</span></code> and
<code class="docutils literal notranslate"><span class="pre">axis3</span></code>). For Euler angles, there is an additional relationship
between <code class="docutils literal notranslate"><span class="pre">axis1</span></code> or <code class="docutils literal notranslate"><span class="pre">axis3</span></code>, with two possibilities:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">axis1</span></code> and <code class="docutils literal notranslate"><span class="pre">axis3</span></code> are also orthogonal (asymmetric sequence)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">axis1</span> <span class="pre">==</span> <span class="pre">axis3</span></code> (symmetric sequence)</p></li>
</ul>
</div></blockquote>
<p>For Davenport angles, this last relationship is relaxed <a href="#id84"><span class="problematic" id="id18">[2]_</span></a>, and only
the consecutive orthogonal axes requirement is maintained.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>axes</strong> (<em>array_like</em><em>, </em><a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape"><em>shape</em></a><em> (</em><em>3</em><em>,</em><em>) or </em><em>(</em><em>...</em><em>, </em><em>[</em><em>1</em><em> or </em><em>2</em><em> or </em><em>3</em><em>]</em><em>, </em><em>3</em><em>)</em>) – Axis of rotation, if one dimensional. If two or more dimensional, describes
the sequence of axes for rotations, where each axes[…, i, :] is the ith
axis. If more than one axis is given, then the second axis must be
orthogonal to both the first and third axes.</p></li>
<li><p><strong>order</strong> (<em>string</em>) – If it is equal to ‘e’ or ‘extrinsic’, the sequence will be
extrinsic. If it is equal to ‘i’ or ‘intrinsic’, sequence
will be treated as intrinsic.</p></li>
<li><p><strong>angles</strong> (<em>float</em><em> or </em><em>array_like</em><em>, </em><a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape"><em>shape</em></a><em> (</em><em>...</em><em>, </em><em>[</em><em>1</em><em> or </em><em>2</em><em> or </em><em>3</em><em>]</em><em>)</em>) – Angles specified in radians (<cite>degrees</cite> is False) or degrees
(<cite>degrees</cite> is True).
Each angle i in the last dimension of <cite>angles</cite> turns around the corresponding
axis axis[…, i, :]. The resulting rotation has the shape
np.broadcast_shapes(np.atleast_2d(axes).shape[:-2], np.atleast_1d(angles).shape[:-1])
Dimensionless angles are thus only valid for a single axis.</p></li>
<li><p><strong>degrees</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, then the given angles are assumed to be in degrees.
Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rotation</strong> – Object containing the rotation represented by the sequence of
rotations around given axes with given angles.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>Rotation</cite> instance</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>from_davenport</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Euler_angles#Definition_by_intrinsic_rotations">https://en.wikipedia.org/wiki/Euler_angles#Definition_by_intrinsic_rotations</a></p>
</aside>
<aside class="footnote brackets" id="id20" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Shuster, Malcolm &amp; Markley, Landis. (2003). Generalization of
the Euler Angles. Journal of the Astronautical Sciences. 51. 123-132.
10.1007/BF03546304.</p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
</pre></div>
</div>
<p>Davenport angles are a generalization of Euler angles, when we use the
canonical basis axes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ex</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ey</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ez</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Initialize a single rotation with a given axis sequence:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ez</span><span class="p">,</span> <span class="n">ey</span><span class="p">,</span> <span class="n">ex</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_davenport</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="s1">&#39;extrinsic&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4,)</span>
</pre></div>
</div>
<p>It is equivalent to Euler angles in this case:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([90.,  0., -0.])</span>
</pre></div>
</div>
<p>Initialize multiple rotations in one object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_davenport</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="s1">&#39;extrinsic&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">35</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">90</span><span class="p">]],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 4)</span>
</pre></div>
</div>
<p>Using only one or two axes is also possible:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_davenport</span><span class="p">([</span><span class="n">ez</span><span class="p">,</span> <span class="n">ex</span><span class="p">],</span> <span class="s1">&#39;extrinsic&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">35</span><span class="p">,</span> <span class="mi">45</span><span class="p">]],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 4)</span>
</pre></div>
</div>
<p>Non-canonical axes are possible, and they do not need to be normalized,
as long as consecutive axes are orthogonal:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_davenport</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="s1">&#39;extrinsic&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>
<span class="go">[ 0.701057,  0.430459, -0.092296,  0.560986]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id21">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_euler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.from_euler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id21" title="Link to this definition">¶</a></dt>
<dd><p>Initialize from Euler angles.</p>
<p>Rotations in 3-D can be represented by a sequence of 3
rotations around a sequence of axes. In theory, any three axes spanning
the 3-D Euclidean space are enough. In practice, the axes of rotation are
chosen to be the basis vectors.</p>
<p>The three rotations can either be in a global frame of reference
(extrinsic) or in a body centred frame of reference (intrinsic), which
is attached to, and moves with, the object under rotation <a href="#id85"><span class="problematic" id="id22">[1]_</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>seq</strong> (<em>string</em>) – Specifies sequence of axes for rotations. Up to 3 characters
belonging to the set {‘X’, ‘Y’, ‘Z’} for intrinsic rotations, or
{‘x’, ‘y’, ‘z’} for extrinsic rotations. Extrinsic and intrinsic
rotations cannot be mixed in one function call.</p></li>
<li><p><strong>angles</strong> (<em>float</em><em> or </em><em>array_like</em><em>, </em><a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape"><em>shape</em></a><em> (</em><em>...</em><em>,  </em><em>[</em><em>1</em><em> or </em><em>2</em><em> or </em><em>3</em><em>]</em><em>)</em>) – Euler angles specified in radians (<cite>degrees</cite> is False) or degrees
(<cite>degrees</cite> is True).
Each character in <cite>seq</cite> defines one axis around which <cite>angles</cite> turns.
The resulting rotation has the shape np.atleast_1d(angles).shape[:-1].
Dimensionless angles are thus only valid for single character <cite>seq</cite>.</p></li>
<li><p><strong>degrees</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, then the given angles are assumed to be in degrees.
Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rotation</strong> – Object containing the rotation represented by the sequence of
rotations around given axes with given angles.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>Rotation</cite> instance</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>from_euler</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id23" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Euler_angles#Definition_by_intrinsic_rotations">https://en.wikipedia.org/wiki/Euler_angles#Definition_by_intrinsic_rotations</a></p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
</pre></div>
</div>
<p>Initialize a single rotation along a single axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4,)</span>
</pre></div>
</div>
<p>Initialize a single rotation with a given axis sequence:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4,)</span>
</pre></div>
</div>
<p>Initialize a stack with a single rotation around a single axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">90</span><span class="p">]],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 4)</span>
</pre></div>
</div>
<p>Initialize a stack with a single rotation with an axis sequence:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">30</span><span class="p">]],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 4)</span>
</pre></div>
</div>
<p>Initialize multiple elementary rotations in one object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">90</span><span class="p">],</span> <span class="p">[</span><span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">]],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 4)</span>
</pre></div>
</div>
<p>Initialize multiple rotations in one object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">35</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">90</span><span class="p">]],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id24">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_valid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.from_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id24" title="Link to this definition">¶</a></dt>
<dd><p>Initialize from rotation matrix.</p>
<p>Rotations in 3 dimensions can be represented with 3 x 3 orthogonal
matrices <a href="#id86"><span class="problematic" id="id25">[1]_</span></a>. If the input is not orthogonal, an approximation is
created by orthogonalizing the input matrix using the method described
in <a href="#id87"><span class="problematic" id="id26">[2]_</span></a>, and then converting the orthogonal rotation matrices to
quaternions using the algorithm described in <a href="#id88"><span class="problematic" id="id27">[3]_</span></a>. Matrices must be
right-handed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>matrix</strong> (<em>array_like</em><em>, </em><a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape"><em>shape</em></a><em> (</em><em>...</em><em>, </em><em>3</em><em>, </em><em>3</em><em>)</em>) – A single matrix or an ND array of matrices, where the last two dimensions
contain the rotation matrices.</p></li>
<li><p><strong>assume_valid</strong> (<em>bool</em><em>, </em><em>optional</em>) – Must be False unless users can guarantee the input is a valid rotation
matrix, i.e. it is orthogonal, rows and columns have unit norm and the
determinant is 1. Setting this to True without ensuring these properties
is unsafe and will silently lead to incorrect results. If True,
normalization steps are skipped, which can improve runtime performance.
Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rotation</strong> – Object containing the rotations represented by the rotation
matrices.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>Rotation</cite> instance</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function was called from_dcm before.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 1.4.0.</span></p>
</div>
<p><strong>Array API Standard Support</strong></p>
<p><cite>from_matrix</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id28" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions">https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions</a></p>
</aside>
<aside class="footnote brackets" id="id29" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Orthogonal_Procrustes_problem">https://en.wikipedia.org/wiki/Orthogonal_Procrustes_problem</a></p>
</aside>
<aside class="footnote brackets" id="id30" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>F. Landis Markley, “Unit Quaternion from Rotation Matrix”,
Journal of guidance, control, and dynamics vol. 31.2, pp.
440-442, 2008.</p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
</pre></div>
</div>
<p>Initialize a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">([</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">single</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 3)</span>
</pre></div>
</div>
<p>Initialize multiple rotations in a single object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">([</span>
<span class="gp">... </span><span class="p">[</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">single</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>If input matrices are not special orthogonal (orthogonal with
determinant equal to +1), then a special orthogonal estimate is stored:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.125</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span>
<span class="go">array([[ 0., -1.,  0.],</span>
<span class="go">       [ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>It is also possible to have a stack containing a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">([[</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[[ 0., -1.,  0.],</span>
<span class="go">        [ 1.,  0.,  0.],</span>
<span class="go">        [ 0.,  0.,  1.]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3, 3)</span>
</pre></div>
</div>
<p>We can also create an N-dimensional array of rotations:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id31">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_mrp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mrp</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.from_mrp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id31" title="Link to this definition">¶</a></dt>
<dd><p>Initialize from Modified Rodrigues Parameters (MRPs).</p>
<p>MRPs are a 3 dimensional vector co-directional to the axis of rotation and whose
magnitude is equal to <code class="docutils literal notranslate"><span class="pre">tan(theta</span> <span class="pre">/</span> <span class="pre">4)</span></code>, where <code class="docutils literal notranslate"><span class="pre">theta</span></code> is the angle of
rotation (in radians) <a href="#id89"><span class="problematic" id="id32">[1]_</span></a>.</p>
<p>MRPs have a singularity at 360 degrees which can be avoided by ensuring the
angle of rotation does not exceed 180 degrees, i.e. switching the direction of
the rotation when it is past 180 degrees.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mrp</strong> (<em>array_like</em><em>, </em><a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape"><em>shape</em></a><em> (</em><em>...</em><em>, </em><em>3</em><em>)</em>) – A single vector or an ND array of vectors, where the last dimension
contains the rotation parameters.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rotation</strong> – Object containing the rotations represented by input MRPs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>Rotation</cite> instance</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 1.6.0.</span></p>
</div>
<p><strong>Array API Standard Support</strong></p>
<p><cite>from_mrp</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id33" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Shuster, M. D. “A Survey of Attitude Representations”,
The Journal of Astronautical Sciences, Vol. 41, No.4, 1993,
pp. 475-476</p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
</pre></div>
</div>
<p>Initialize a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_mrp</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([0.        , 0.        , 180.      ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
</pre></div>
</div>
<p>Initialize multiple rotations in one object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_mrp</span><span class="p">([</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[0.        , 0.        , 180.      ],</span>
<span class="go">       [180.0     , 0.        , 0.        ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
</pre></div>
</div>
<p>It is also possible to have a stack of a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_mrp</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id34">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_quat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quat</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar_first</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.from_quat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id34" title="Link to this definition">¶</a></dt>
<dd><p>Initialize from quaternions.</p>
<p>Rotations in 3 dimensions can be represented using unit norm
quaternions <a href="#id90"><span class="problematic" id="id35">[1]_</span></a>.</p>
<p>The 4 components of a quaternion are divided into a scalar part <code class="docutils literal notranslate"><span class="pre">w</span></code>
and a vector part <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> and can be expressed from the angle
<code class="docutils literal notranslate"><span class="pre">theta</span></code> and the axis <code class="docutils literal notranslate"><span class="pre">n</span></code> of a rotation as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_x</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_y</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_z</span>
</pre></div>
</div>
<p>There are 2 conventions to order the components in a quaternion:</p>
<ul>
<li><p>scalar-first order – <code class="docutils literal notranslate"><span class="pre">(w,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code></p></li>
<li><p>scalar-last order – <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z,</span> <span class="pre">w)</span></code></p></li>
</ul>
<p>The choice is controlled by <cite>scalar_first</cite> argument.
By default, it is False and the scalar-last order is assumed.</p>
<p>Advanced users may be interested in the “double cover” of 3D space by
the quaternion representation <a href="#id91"><span class="problematic" id="id36">[2]_</span></a>. As of version 1.11.0, the
following subset (and only this subset) of operations on a <cite>Rotation</cite>
<code class="docutils literal notranslate"><span class="pre">r</span></code> corresponding to a quaternion <code class="docutils literal notranslate"><span class="pre">q</span></code> are guaranteed to preserve
the double cover property: <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">Rotation.from_quat(q)</span></code>,
<code class="docutils literal notranslate"><span class="pre">r.as_quat(canonical=False)</span></code>, <code class="docutils literal notranslate"><span class="pre">r.inv()</span></code>, and composition using the
<code class="docutils literal notranslate"><span class="pre">*</span></code> operator such as <code class="docutils literal notranslate"><span class="pre">r*r</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>quat</strong> (<em>array_like</em><em>, </em><a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape"><em>shape</em></a><em> (</em><em>...</em><em>, </em><em>4</em><em>)</em>) – Each row is a (possibly non-unit norm) quaternion representing an
active rotation. Each quaternion will be normalized to unit norm.</p></li>
<li><p><strong>scalar_first</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether the scalar component goes first or last.
Default is False, i.e. the scalar-last order is assumed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rotation</strong> – Object containing the rotations represented by input quaternions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>Rotation</cite> instance</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>from_quat</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id37" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation</a></p>
</aside>
<aside class="footnote brackets" id="id38" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Hanson, Andrew J. “Visualizing quaternions.”
Morgan Kaufmann Publishers Inc., San Francisco, CA. 2006.</p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
</pre></div>
</div>
<p>A rotation can be initialized from a quaternion with the scalar-last
(default) or scalar-first component order as shown below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_quat</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[1., 0., 0.],</span>
<span class="go">       [0., 1., 0.],</span>
<span class="go">       [0., 0., 1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_quat</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">scalar_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[1., 0., 0.],</span>
<span class="go">       [0., 1., 0.],</span>
<span class="go">       [0., 0., 1.]])</span>
</pre></div>
</div>
<p>It is possible to initialize multiple rotations in a single object by
passing an N-dimensional array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_quat</span><span class="p">([[</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>
<span class="go">array([[[1., 0., 0., 0.],</span>
<span class="go">        [0., 0., 0., 1.]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 2, 4)</span>
</pre></div>
</div>
<p>It is also possible to have a stack of a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_quat</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>
<span class="go">array([[0., 0., 0., 1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 4)</span>
</pre></div>
</div>
<p>Quaternions are normalized before initialization.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_quat</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>
<span class="go">array([0.        , 0.        , 0.70710678, 0.70710678])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id39">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_rotvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.from_rotvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id39" title="Link to this definition">¶</a></dt>
<dd><p>Initialize from rotation vectors.</p>
<p>A rotation vector is a 3 dimensional vector which is co-directional to
the axis of rotation and whose norm gives the angle of rotation <a href="#id92"><span class="problematic" id="id40">[1]_</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>rotvec</strong> (<em>array_like</em><em>, </em><a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape"><em>shape</em></a><em> (</em><em>...</em><em>, </em><em>3</em><em>)</em>) – A single vector or an ND array of vectors, where the last dimension
contains the rotation vectors.</p></li>
<li><p><strong>degrees</strong> (<em>bool</em><em>, </em><em>optional</em>) – <p>If True, then the given magnitudes are assumed to be in degrees.
Default is False.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 1.7.0.</span></p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rotation</strong> – Object containing the rotations represented by input rotation
vectors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>Rotation</cite> instance</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>from_rotvec</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id41" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation#Rotation_vector">https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation#Rotation_vector</a></p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
</pre></div>
</div>
<p>Initialize a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="go">array([0.        , 0.        , 1.57079633])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
</pre></div>
</div>
<p>Initialize a rotation in degrees, and view it in degrees:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="mi">45</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">(</span><span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([ 0., 45.,  0.])</span>
</pre></div>
</div>
<p>Initialize multiple rotations in one object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="go">array([[0.        , 0.        , 1.57079633],</span>
<span class="go">       [1.57079633, 0.        , 0.        ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
</pre></div>
</div>
<p>It is also possible to have a stack of a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id42">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">identity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.identity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id42" title="Link to this definition">¶</a></dt>
<dd><p>Get identity rotation(s).</p>
<p>Composition with the identity rotation has no effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>num</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Number of identity rotations to generate. If None (default), then a
single rotation is generated.</p></li>
<li><p><strong>shape</strong> (<em>int</em><em> or </em><em>tuple</em><em> of </em><em>ints</em><em>, </em><em>optional</em>) – Shape of identity rotations to generate. If specified, <cite>num</cite> must
be None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>identity</strong> – The identity rotation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Rotation object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id43">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">random</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.random"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id43" title="Link to this definition">¶</a></dt>
<dd><p>Generate rotations that are uniformly distributed on a sphere.</p>
<p>Formally, the rotations follow the Haar-uniform distribution over the SO(3)
group.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>num</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Number of random rotations to generate. If None (default), then a
single rotation is generated.</p></li>
<li><p><strong>rng</strong> ({None, int, <cite>numpy.random.Generator</cite>}, optional) – <p>If <cite>rng</cite> is passed by keyword, types other than <cite>numpy.random.Generator</cite> are
passed to <cite>numpy.random.default_rng</cite> to instantiate a <code class="docutils literal notranslate"><span class="pre">Generator</span></code>.
If <cite>rng</cite> is already a <code class="docutils literal notranslate"><span class="pre">Generator</span></code> instance, then the provided instance is
used. Specify <cite>rng</cite> for repeatable function behavior.</p>
<p>If this argument is passed by position or <cite>random_state</cite> is passed by keyword,
legacy behavior for the argument <cite>random_state</cite> applies:</p>
<ul>
<li><p>If <cite>random_state</cite> is None (or <cite>numpy.random</cite>), the <cite>numpy.random.RandomState</cite>
singleton is used.</p></li>
<li><p>If <cite>random_state</cite> is an int, a new <code class="docutils literal notranslate"><span class="pre">RandomState</span></code> instance is used,
seeded with <cite>random_state</cite>.</p></li>
<li><p>If <cite>random_state</cite> is already a <code class="docutils literal notranslate"><span class="pre">Generator</span></code> or <code class="docutils literal notranslate"><span class="pre">RandomState</span></code> instance then
that instance is used.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.15.0: </span>As part of the <a class="reference external" href="https://scientific-python.org/specs/spec-0007/">SPEC-007</a>
transition from use of <cite>numpy.random.RandomState</cite> to
<cite>numpy.random.Generator</cite>, this keyword was changed from <cite>random_state</cite> to <cite>rng</cite>.
For an interim period, both keywords will continue to work, although only one
may be specified at a time. After the interim period, function calls using the
<cite>random_state</cite> keyword will emit warnings. The behavior of both <cite>random_state</cite> and
<cite>rng</cite> are outlined above, but only the <cite>rng</cite> keyword should be used in new code.</p>
</div>
</p></li>
<li><p><strong>shape</strong> (<em>tuple</em><em> of </em><em>ints</em><em>, </em><em>optional</em>) – Shape of random rotations to generate. If specified, <cite>num</cite> must be None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>random_rotation</strong> – Contains a single rotation if <cite>num</cite> is None. Otherwise contains a
stack of <cite>num</cite> rotations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>Rotation</cite> instance</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.stats.special_ortho_group()</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function is optimized for efficiently sampling random rotation
matrices in three dimensions. For generating random rotation matrices
in higher dimensions, see <cite>scipy.stats.special_ortho_group</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
</pre></div>
</div>
<p>Sample a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">R</span><span class="o">.</span><span class="n">random</span><span class="p">()</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zxy&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([-110.5976185 ,   55.32758512,   76.3289269 ])  # random</span>
</pre></div>
</div>
<p>Sample a stack of rotations:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">R</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zxy&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[-110.5976185 ,   55.32758512,   76.3289269 ],  # random</span>
<span class="go">       [ -91.59132005,  -14.3629884 ,  -93.91933182],</span>
<span class="go">       [  25.23835501,   45.02035145, -121.67867086],</span>
<span class="go">       [ -51.51414184,  -15.29022692, -172.46870023],</span>
<span class="go">       [ -81.63376847,  -27.39521579,    2.60408416]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id44">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id44" title="Link to this definition">¶</a></dt>
<dd><p>Apply this rotation to a set of vectors.</p>
<p>If the original frame rotates to the final frame by this rotation, then
its application to a vector can be seen in two ways:</p>
<blockquote>
<div><ul>
<li><p>As a projection of vector components expressed in the final frame
to the original frame.</p></li>
<li><p>As the physical rotation of a vector being glued to the original
frame as it rotates. In this case the vector components are
expressed in the original frame before and after the rotation.</p></li>
</ul>
</div></blockquote>
<p>In terms of rotation matrices, this application is the same as
<code class="docutils literal notranslate"><span class="pre">self.as_matrix()</span> <span class="pre">&#64;</span> <span class="pre">vectors</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>vectors</strong> (<em>array_like</em><em>, </em><a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape"><em>shape</em></a><em> (</em><em>...</em><em>, </em><em>3</em><em>)</em>) – Each <cite>vectors[…, :]</cite> represents a vector in 3D space. The shape of
rotations and shape of vectors given must follow standard numpy
broadcasting rules: either one of them equals unity or they both
equal each other.</p></li>
<li><p><strong>inverse</strong> (<em>boolean</em><em>, </em><em>optional</em>) – If True then the inverse of the rotation(s) is applied to the input
vectors. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rotated_vectors</strong> – Result of applying rotation on input vectors.
Shape is determined according to numpy broadcasting rules. I.e., the result
will have the shape <cite>np.broadcast_shapes(r.shape, v.shape[:-1]) + (3,)</cite></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, <a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape">shape</a> (…, 3)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>apply</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>⛔</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
</pre></div>
</div>
<p>Single rotation applied on a single vector:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="go">       [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="go">       [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
<span class="go">array([2.22044605e-16, 1.00000000e+00, 0.00000000e+00])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
</pre></div>
</div>
<p>Single rotation applied on multiple vectors:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[ 0.70710678, -0.70710678,  0.        ],</span>
<span class="go">       [ 0.70710678,  0.70710678,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  1.        ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
<span class="go">array([[ 0.70710678,  0.70710678,  0.        ],</span>
<span class="go">       [-0.70710678,  2.12132034,  3.        ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
</pre></div>
</div>
<p>Multiple rotations on a single vector:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[[ 7.07106781e-01, -7.07106781e-01,  0.00000000e+00],</span>
<span class="go">        [ 7.07106781e-01,  7.07106781e-01,  0.00000000e+00],</span>
<span class="go">        [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]],</span>
<span class="go">       [[ 1.00000000e+00,  0.00000000e+00,  0.00000000e+00],</span>
<span class="go">        [ 0.00000000e+00,  2.22044605e-16, -1.00000000e+00],</span>
<span class="go">        [ 0.00000000e+00,  1.00000000e+00,  2.22044605e-16]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
<span class="go">array([[-0.70710678,  2.12132034,  3.        ],</span>
<span class="go">       [ 1.        , -3.        ,  2.        ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
</pre></div>
</div>
<p>Multiple rotations on multiple vectors. Each rotation is applied on the
corresponding vector:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;zxy&#39;</span><span class="p">,</span> <span class="p">[</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">]],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vectors</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
<span class="go">array([[ 3.        ,  2.        , -1.        ],</span>
<span class="go">       [-0.09026039,  1.11237244, -0.86860844]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
</pre></div>
</div>
<p>Broadcasting rules apply:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">],</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">vectors</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((5, 1, 4), (3, 4, 3))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 3, 4, 3)</span>
</pre></div>
</div>
<p>It is also possible to apply the inverse rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;zxy&#39;</span><span class="p">,</span> <span class="p">[</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">]],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vectors</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[-3.        ,  2.        ,  1.        ],</span>
<span class="go">       [ 1.09533535, -0.8365163 ,  0.3169873 ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id45">
<span class="sig-name descname"><span class="pre">approx_equal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.approx_equal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id45" title="Link to this definition">¶</a></dt>
<dd><p>Determine if another rotation is approximately equal to this one.</p>
<p>Equality is measured by calculating the smallest angle between the
rotations, and checking to see if it is smaller than <cite>atol</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>other</strong> (<cite>Rotation</cite> instance) – Object containing the rotations to measure against this one.</p></li>
<li><p><strong>atol</strong> (<em>float</em><em>, </em><em>optional</em>) – The absolute angular tolerance, below which the rotations are
considered equal. If not given, then set to 1e-8 radians by
default.</p></li>
<li><p><strong>degrees</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True and <cite>atol</cite> is given, then <cite>atol</cite> is measured in degrees. If
False (default), then atol is measured in radians.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>approx_equal</strong> – Whether the rotations are approximately equal, bool if object
contains a single rotation and ndarray if object contains multiple
rotations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray or bool</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>approx_equal</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_quat</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_quat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">approx_equal</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="go">array([False, False, False, True])</span>
</pre></div>
</div>
<p>Approximate equality for a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">approx_equal</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id46">
<span class="sig-name descname"><span class="pre">as_davenport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">suppress_warnings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.as_davenport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id46" title="Link to this definition">¶</a></dt>
<dd><p>Represent as Davenport angles.</p>
<p>Any orientation can be expressed as a composition of 3 elementary
rotations.</p>
<p>For both Euler angles and Davenport angles, consecutive axes must
be are orthogonal (<code class="docutils literal notranslate"><span class="pre">axis2</span></code> is orthogonal to both <code class="docutils literal notranslate"><span class="pre">axis1</span></code> and
<code class="docutils literal notranslate"><span class="pre">axis3</span></code>). For Euler angles, there is an additional relationship
between <code class="docutils literal notranslate"><span class="pre">axis1</span></code> or <code class="docutils literal notranslate"><span class="pre">axis3</span></code>, with two possibilities:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">axis1</span></code> and <code class="docutils literal notranslate"><span class="pre">axis3</span></code> are also orthogonal (asymmetric sequence)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">axis1</span> <span class="pre">==</span> <span class="pre">axis3</span></code> (symmetric sequence)</p></li>
</ul>
</div></blockquote>
<p>For Davenport angles, this last relationship is relaxed <a href="#id93"><span class="problematic" id="id47">[1]_</span></a>, and only
the consecutive orthogonal axes requirement is maintained.</p>
<p>A slightly modified version of the algorithm from <a href="#id94"><span class="problematic" id="id48">[2]_</span></a> has been used to
calculate Davenport angles for the rotation about a given sequence of
axes.</p>
<p>Davenport angles, just like Euler angles, suffer from the problem of
gimbal lock <a href="#id95"><span class="problematic" id="id49">[3]_</span></a>, where the representation loses a degree of freedom
and it is not possible to determine the first and third angles
uniquely. In this case, a warning is raised (unless the
<code class="docutils literal notranslate"><span class="pre">suppress_warnings</span></code> option is used), and the third angle is set
to zero. Note however that the returned angles still represent the
correct rotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>axes</strong> (<em>array_like</em><em>, </em><a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape"><em>shape</em></a><em> (</em><em>...</em><em>, </em><em>[</em><em>1</em><em> or </em><em>2</em><em> or </em><em>3</em><em>]</em><em>, </em><em>3</em><em>) or </em><em>(</em><em>...</em><em>, </em><em>3</em><em>)</em>) – Axis of rotation, if one dimensional. If N dimensional, describes the
sequence of axes for rotations, where each axes[…, i, :] is the ith
axis. If more than one axis is given, then the second axis must be
orthogonal to both the first and third axes.</p></li>
<li><p><strong>order</strong> (<em>string</em>) – If it belongs to the set {‘e’, ‘extrinsic’}, the sequence will be
extrinsic. If it belongs to the set {‘i’, ‘intrinsic’}, sequence
will be treated as intrinsic.</p></li>
<li><p><strong>degrees</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Returned angles are in degrees if this flag is True, else they are
in radians. Default is False.</p></li>
<li><p><strong>suppress_warnings</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Disable warnings about gimbal lock. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>angles</strong> – Shape depends on shape of inputs used to initialize object.
The returned angles are in the range:</p>
<ul>
<li><p>First angle belongs to [-180, 180] degrees (both inclusive)</p></li>
<li><p>Third angle belongs to [-180, 180] degrees (both inclusive)</p></li>
<li><p>Second angle belongs to a set of size 180 degrees,
given by: <code class="docutils literal notranslate"><span class="pre">[-abs(lambda),</span> <span class="pre">180</span> <span class="pre">-</span> <span class="pre">abs(lambda)]</span></code>, where <code class="docutils literal notranslate"><span class="pre">lambda</span></code>
is the angle between the first and third axes.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, <a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape">shape</a> (…, 3)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>as_davenport</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>⛔</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id50" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Shuster, Malcolm &amp; Markley, Landis. (2003). Generalization of
the Euler Angles. Journal of the Astronautical Sciences. 51. 123-132.
10.1007/BF03546304.</p>
</aside>
<aside class="footnote brackets" id="id51" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Bernardes E, Viollet S (2022) Quaternion to Euler angles
conversion: A direct, general and computationally efficient method.
PLoS ONE 17(11): e0276302. 10.1371/journal.pone.0276302</p>
</aside>
<aside class="footnote brackets" id="id52" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Gimbal_lock#In_applied_mathematics">https://en.wikipedia.org/wiki/Gimbal_lock#In_applied_mathematics</a></p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
</pre></div>
</div>
<p>Davenport angles are a generalization of Euler angles, when we use the
canonical basis axes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ex</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ey</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ez</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Represent a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_davenport</span><span class="p">([</span><span class="n">ez</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">ey</span><span class="p">],</span> <span class="s1">&#39;extrinsic&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([90.,  0.,  0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zxy&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([90.,  0.,  0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_davenport</span><span class="p">([</span><span class="n">ez</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">ey</span><span class="p">],</span> <span class="s1">&#39;extrinsic&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
</pre></div>
</div>
<p>Represent a stack of single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_davenport</span><span class="p">([</span><span class="n">ez</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">ey</span><span class="p">],</span> <span class="s1">&#39;extrinsic&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[90.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_davenport</span><span class="p">([</span><span class="n">ez</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">ey</span><span class="p">],</span> <span class="s1">&#39;extrinsic&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3)</span>
</pre></div>
</div>
<p>Represent multiple rotations in a single object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_davenport</span><span class="p">([</span><span class="n">ez</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">ey</span><span class="p">],</span> <span class="s1">&#39;extrinsic&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[90.,  0.,  0.],</span>
<span class="go">       [ 0., 45.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_davenport</span><span class="p">([</span><span class="n">ez</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">ey</span><span class="p">],</span> <span class="s1">&#39;extrinsic&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id53">
<span class="sig-name descname"><span class="pre">as_euler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">suppress_warnings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.as_euler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id53" title="Link to this definition">¶</a></dt>
<dd><p>Represent as Euler angles.</p>
<p>Any orientation can be expressed as a composition of 3 elementary
rotations. Once the axis sequence has been chosen, Euler angles define
the angle of rotation around each respective axis <a href="#id96"><span class="problematic" id="id54">[1]_</span></a>.</p>
<p>The algorithm from <a href="#id97"><span class="problematic" id="id55">[2]_</span></a> has been used to calculate Euler angles for the
rotation about a given sequence of axes.</p>
<p>Euler angles suffer from the problem of gimbal lock <a href="#id98"><span class="problematic" id="id56">[3]_</span></a>, where the
representation loses a degree of freedom and it is not possible to
determine the first and third angles uniquely. In this case,
a warning is raised (unless the <code class="docutils literal notranslate"><span class="pre">suppress_warnings</span></code> option is used),
and the third angle is set to zero. Note however that the returned
angles still represent the correct rotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>seq</strong> (<em>string</em><em>, </em><em>length 3</em>) – 3 characters belonging to the set {‘X’, ‘Y’, ‘Z’} for intrinsic
rotations, or {‘x’, ‘y’, ‘z’} for extrinsic rotations <a href="#id99"><span class="problematic" id="id57">[1]_</span></a>.
Adjacent axes cannot be the same.
Extrinsic and intrinsic rotations cannot be mixed in one function
call.</p></li>
<li><p><strong>degrees</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Returned angles are in degrees if this flag is True, else they are
in radians. Default is False.</p></li>
<li><p><strong>suppress_warnings</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Disable warnings about gimbal lock. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>angles</strong> – Shape depends on shape of inputs used to initialize object.
The returned angles are in the range:</p>
<ul>
<li><p>First angle belongs to [-180, 180] degrees (both inclusive)</p></li>
<li><p>Third angle belongs to [-180, 180] degrees (both inclusive)</p></li>
<li><p>Second angle belongs to:</p>
<blockquote>
<div><ul>
<li><p>[-90, 90] degrees if all axes are different (like xyz)</p></li>
<li><p>[0, 180] degrees if first and third axes are the same
(like zxz)</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, <a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape">shape</a> (…, 3)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>as_euler</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id58" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Euler_angles#Definition_by_intrinsic_rotations">https://en.wikipedia.org/wiki/Euler_angles#Definition_by_intrinsic_rotations</a></p>
</aside>
<aside class="footnote brackets" id="id59" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Bernardes E, Viollet S (2022) Quaternion to Euler angles
conversion: A direct, general and computationally efficient
method. PLoS ONE 17(11): e0276302.
<a class="reference external" href="https://doi.org/10.1371/journal.pone.0276302">https://doi.org/10.1371/journal.pone.0276302</a></p>
</aside>
<aside class="footnote brackets" id="id60" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Gimbal_lock#In_applied_mathematics">https://en.wikipedia.org/wiki/Gimbal_lock#In_applied_mathematics</a></p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
</pre></div>
</div>
<p>Represent a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zxy&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([90.,  0.,  0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zxy&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
</pre></div>
</div>
<p>Represent a stack of single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zxy&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[90.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zxy&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3)</span>
</pre></div>
</div>
<p>Represent multiple rotations in a single object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zxy&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[ 90.,   0.,   0.],</span>
<span class="go">       [  0.,   0., -60.],</span>
<span class="go">       [  0.,  45.,   0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zxy&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id61">
<span class="sig-name descname"><span class="pre">as_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.as_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id61" title="Link to this definition">¶</a></dt>
<dd><p>Represent as rotation matrix.</p>
<p>3D rotations can be represented using rotation matrices, which
are 3 x 3 real orthogonal matrices with determinant equal to +1 <a href="#id100"><span class="problematic" id="id62">[1]_</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> – Shape depends on shape of inputs used for initialization.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray, <a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape">shape</a> (…, 3)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function was called as_dcm before.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 1.4.0.</span></p>
</div>
<p><strong>Array API Standard Support</strong></p>
<p><cite>as_matrix</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id63" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions">https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions</a></p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
</pre></div>
</div>
<p>Represent a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="go">       [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="go">       [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 3)</span>
</pre></div>
</div>
<p>Represent a stack with a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_quat</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[[ 0.,  1.,  0.],</span>
<span class="go">        [ 1.,  0.,  0.],</span>
<span class="go">        [ 0.,  0., -1.]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3, 3)</span>
</pre></div>
</div>
<p>Represent multiple rotations:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="go">array([[[ 1.00000000e+00,  0.00000000e+00,  0.00000000e+00],</span>
<span class="go">        [ 0.00000000e+00,  2.22044605e-16, -1.00000000e+00],</span>
<span class="go">        [ 0.00000000e+00,  1.00000000e+00,  2.22044605e-16]],</span>
<span class="go">       [[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="go">        [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="go">        [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id64">
<span class="sig-name descname"><span class="pre">as_mrp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.as_mrp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id64" title="Link to this definition">¶</a></dt>
<dd><p>Represent as Modified Rodrigues Parameters (MRPs).</p>
<p>MRPs are a 3 dimensional vector co-directional to the axis of rotation and whose
magnitude is equal to <code class="docutils literal notranslate"><span class="pre">tan(theta</span> <span class="pre">/</span> <span class="pre">4)</span></code>, where <code class="docutils literal notranslate"><span class="pre">theta</span></code> is the angle of
rotation (in radians) <a href="#id101"><span class="problematic" id="id65">[1]_</span></a>.</p>
<p>MRPs have a singularity at 360 degrees which can be avoided by ensuring the
angle of rotation does not exceed 180 degrees, i.e. switching the direction of
the rotation when it is past 180 degrees. This function will always return MRPs
corresponding to a rotation of less than or equal to 180 degrees.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mrps</strong> – Shape depends on shape of inputs used for initialization.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray, <a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape">shape</a> (…, 3)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 1.6.0.</span></p>
</div>
<p><strong>Array API Standard Support</strong></p>
<p><cite>as_mrp</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id66" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Shuster, M. D. “A Survey of Attitude Representations”,
The Journal of Astronautical Sciences, Vol. 41, No.4, 1993,
pp. 475-476</p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
</pre></div>
</div>
<p>Represent a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_mrp</span><span class="p">()</span>
<span class="go">array([0.        , 0.        , 1.         ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_mrp</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
</pre></div>
</div>
<p>Represent a stack with a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">180</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_mrp</span><span class="p">()</span>
<span class="go">array([[1.       , 0.        , 0.         ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_mrp</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3)</span>
</pre></div>
</div>
<p>Represent multiple rotations:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_mrp</span><span class="p">()</span>
<span class="go">array([[0.41421356, 0.        , 0.        ],</span>
<span class="go">       [0.        , 0.        , 0.41421356]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_mrp</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id67">
<span class="sig-name descname"><span class="pre">as_quat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">canonical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar_first</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.as_quat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id67" title="Link to this definition">¶</a></dt>
<dd><p>Represent as quaternions.</p>
<p>Rotations in 3 dimensions can be represented using unit norm
quaternions <a href="#id102"><span class="problematic" id="id68">[1]_</span></a>.</p>
<p>The 4 components of a quaternion are divided into a scalar part <code class="docutils literal notranslate"><span class="pre">w</span></code>
and a vector part <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> and can be expressed from the angle
<code class="docutils literal notranslate"><span class="pre">theta</span></code> and the axis <code class="docutils literal notranslate"><span class="pre">n</span></code> of a rotation as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_x</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_y</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_z</span>
</pre></div>
</div>
<p>There are 2 conventions to order the components in a quaternion:</p>
<ul>
<li><p>scalar-first order – <code class="docutils literal notranslate"><span class="pre">(w,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code></p></li>
<li><p>scalar-last order – <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z,</span> <span class="pre">w)</span></code></p></li>
</ul>
<p>The choice is controlled by <cite>scalar_first</cite> argument.
By default, it is False and the scalar-last order is used.</p>
<p>The mapping from quaternions to rotations is
two-to-one, i.e. quaternions <code class="docutils literal notranslate"><span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">-q</span></code>, where <code class="docutils literal notranslate"><span class="pre">-q</span></code> simply
reverses the sign of each component, represent the same spatial
rotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>canonical</strong> (<cite>bool</cite>, default False) – Whether to map the redundant double cover of rotation space to a
unique “canonical” single cover. If True, then the quaternion is
chosen from {q, -q} such that the w term is positive. If the w term
is 0, then the quaternion is chosen such that the first nonzero
term of the x, y, and z terms is positive.</p></li>
<li><p><strong>scalar_first</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether the scalar component goes first or last.
Default is False, i.e. the scalar-last order is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>quat</strong> – Shape depends on shape of inputs used for initialization.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>numpy.ndarray</cite>, shape (…, 4)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>as_quat</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id69" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation</a></p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
</pre></div>
</div>
<p>A rotation can be represented as a quaternion with either scalar-last
(default) or scalar-first component order.
This is shown for a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>
<span class="go">array([0., 0., 0., 1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">(</span><span class="n">scalar_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([1., 0., 0., 0.])</span>
</pre></div>
</div>
<p>The resulting shape of the quaternion is always the shape of the Rotation
object with an added last dimension of size 4. E.g. when the <cite>Rotation</cite> object
contains an N-dimensional array (N, M, K) of rotations, the result will be a
4-dimensional array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3, 4, 4)</span>
</pre></div>
</div>
<p>Quaternions can be mapped from a redundant double cover of the
rotation space to a canonical representation with a positive w term.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_quat</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>
<span class="go">array([0. , 0. , 0. , -1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">(</span><span class="n">canonical</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([0. , 0. , 0. , 1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id70">
<span class="sig-name descname"><span class="pre">as_rotvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.as_rotvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id70" title="Link to this definition">¶</a></dt>
<dd><p>Represent as rotation vectors.</p>
<p>A rotation vector is a 3 dimensional vector which is co-directional to
the axis of rotation and whose norm gives the angle of rotation <a href="#id103"><span class="problematic" id="id71">[1]_</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>degrees</strong> (<em>boolean</em><em>, </em><em>optional</em>) – <p>Returned magnitudes are in degrees if this flag is True, else they are
in radians. Default is False.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 1.7.0.</span></p>
</div>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rotvec</strong> – Shape depends on shape of inputs used for initialization.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, <a class="reference internal" href="#astrix.spatial.Rotation.shape" title="astrix.spatial.Rotation.shape">shape</a> (…, 3)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>as_rotvec</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id72" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation#Rotation_vector">https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation#Rotation_vector</a></p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
</pre></div>
</div>
<p>Represent a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="go">array([0.        , 0.        , 1.57079633])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
</pre></div>
</div>
<p>Represent a rotation in degrees:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;YX&#39;</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">),</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">(</span><span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">array([-69.2820323, -69.2820323, -69.2820323])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">120.00000000000001</span>
</pre></div>
</div>
<p>Represent a stack with a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_quat</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="go">array([[0.        , 0.        , 1.57079633]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3)</span>
</pre></div>
</div>
<p>Represent multiple rotations in a single object:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_quat</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="go">array([[0.        , 0.        , 1.57079633],</span>
<span class="go">       [1.35102172, 1.35102172, 0.        ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id73">
<span class="sig-name descname"><span class="pre">inv</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.inv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id73" title="Link to this definition">¶</a></dt>
<dd><p>Invert this rotation.</p>
<p>Composition of a rotation with its inverse results in an identity
transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>inverse</strong> – Object containing inverse of the rotations in the current instance.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>Rotation</cite> instance</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>inv</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
</pre></div>
</div>
<p>Inverting a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([-45.,   0.,   0.])</span>
</pre></div>
</div>
<p>Inverting multiple rotations:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="go">array([[-0.        , -0.        , -1.04719755],</span>
<span class="go">       [ 0.78539816, -0.        , -0.        ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id74">
<span class="sig-name descname"><span class="pre">magnitude</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.magnitude"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id74" title="Link to this definition">¶</a></dt>
<dd><p>Get the magnitude(s) of the rotation(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>magnitude</strong> – Angle(s) in radians, float if object contains a single rotation
and ndarray if object contains ND rotations. The magnitude
will always be in the range [0, pi].</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray or float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>magnitude</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_quat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>
<span class="go">array([[ 1., 0., 0., 0.],</span>
<span class="go">       [ 0., 1., 0., 0.],</span>
<span class="go">       [ 0., 0., 1., 0.],</span>
<span class="go">       [ 0., 0., 0., 1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">magnitude</span><span class="p">()</span>
<span class="go">array([3.14159265, 3.14159265, 3.14159265, 0.        ])</span>
</pre></div>
</div>
<p>Magnitude of a single rotation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">magnitude</span><span class="p">()</span>
<span class="go">3.141592653589793</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id75">
<span class="sig-name descname"><span class="pre">mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id75" title="Link to this definition">¶</a></dt>
<dd><p>Get the mean of the rotations.</p>
<p>The mean used is the chordal L2 mean (also called the projected or
induced arithmetic mean) <a href="#id104"><span class="problematic" id="id76">[1]_</span></a>. If <code class="docutils literal notranslate"><span class="pre">A</span></code> is a set of rotation matrices,
then the mean <code class="docutils literal notranslate"><span class="pre">M</span></code> is the rotation matrix that minimizes the
following loss function:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[L(M) = \sum_{i = 1}^{n} w_i \lVert \mathbf{A}_i -
\mathbf{M} \rVert^2 ,\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(w_i\)</span>’s are the <cite>weights</cite> corresponding to each matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>weights</strong> (<em>array_like shape</em><em> (</em><em>...</em><em>, </em><em>N</em><em>)</em><em>, </em><em>optional</em>) – Weights describing the relative importance of the rotations. If
None (default), then all values in <cite>weights</cite> are assumed to be
equal. If given, the shape of <cite>weights</cite> must be broadcastable to
the rotation shape. Weights must be non-negative.</p></li>
<li><p><strong>axis</strong> (<em>None</em><em>, </em><em>int</em><em>, or </em><em>tuple</em><em> of </em><em>ints</em><em>, </em><em>optional</em>) – Axis or axes along which the means are computed. The default is to
compute the mean of all rotations.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mean</strong> – Single rotation containing the mean of the rotations in the
current instance.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>Rotation</cite> instance</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>mean</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id77" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Hartley, Richard, et al.,
“Rotation Averaging”, International Journal of Computer Vision
103, 2013, pp. 267-305.</p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([0.24945696, 0.25054542, 0.24945696])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id78">
<span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scipy/spatial/transform/_rotation.html#Rotation.reduce"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id78" title="Link to this definition">¶</a></dt>
<dd><p>Reduce this rotation with the provided rotation groups.</p>
<p>Reduction of a rotation <code class="docutils literal notranslate"><span class="pre">p</span></code> is a transformation of the form
<code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">=</span> <span class="pre">l</span> <span class="pre">*</span> <span class="pre">p</span> <span class="pre">*</span> <span class="pre">r</span></code>, where <code class="docutils literal notranslate"><span class="pre">l</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span></code> are chosen from <cite>left</cite> and
<cite>right</cite> respectively, such that rotation <code class="docutils literal notranslate"><span class="pre">q</span></code> has the smallest
magnitude.</p>
<p>If <cite>left</cite> and <cite>right</cite> are rotation groups representing symmetries of
two objects rotated by <code class="docutils literal notranslate"><span class="pre">p</span></code>, then <code class="docutils literal notranslate"><span class="pre">q</span></code> is the rotation of the
smallest magnitude to align these objects considering their symmetries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>left</strong> (<cite>Rotation</cite> instance, optional) – Object containing the left rotation(s). Default value (None)
corresponds to the identity rotation.</p></li>
<li><p><strong>right</strong> (<cite>Rotation</cite> instance, optional) – Object containing the right rotation(s). Default value (None)
corresponds to the identity rotation.</p></li>
<li><p><strong>return_indices</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to return the indices of the rotations from <cite>left</cite> and
<cite>right</cite> used for reduction.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a> | <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>[<a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul>
<li><p><strong>reduced</strong> (<cite>Rotation</cite> instance) – Object containing reduced rotations.</p></li>
<li><p><strong>left_best, right_best</strong> (<em>integer ndarray</em>) – Indices of elements from <cite>left</cite> and <cite>right</cite> used for reduction.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Array API Standard Support</strong></p>
<p><cite>reduce</cite> has experimental support for Python Array API Standard compatible
backends in addition to NumPy. Please consider testing these features
by setting an environment variable <code class="docutils literal notranslate"><span class="pre">SCIPY_ARRAY_API=1</span></code> and providing
CuPy, PyTorch, JAX, or Dask arrays as array arguments. The following
combinations of backend and device (or other capability) are supported.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Library</p></th>
<th class="head"><p>CPU</p></th>
<th class="head"><p>GPU</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NumPy</p></td>
<td><p>✅</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-odd"><td><p>CuPy</p></td>
<td><p>n/a</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>PyTorch</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-odd"><td><p>JAX</p></td>
<td><p>✅</p></td>
<td><p>✅</p></td>
</tr>
<tr class="row-even"><td><p>Dask</p></td>
<td><p>⛔</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<div><p>See <span class="xref std std-ref">dev-arrayapi</span> for more information.</p>
</div></blockquote>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Rotation.shape">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">shape</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span></span><a class="headerlink" href="#astrix.spatial.Rotation.shape" title="Link to this definition">¶</a></dt>
<dd><p>The shape of the rotation’s leading dimensions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id79">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">single</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></span><a class="headerlink" href="#id79" title="Link to this definition">¶</a></dt>
<dd><p>Whether this instance represents a single rotation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="astrix.spatial.RotationSequence">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">RotationSequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/rotation.html#RotationSequence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.RotationSequence" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="astrix.spatial.rotation.html#astrix.spatial.rotation.RotationLike" title="astrix.spatial.rotation.RotationLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotationLike</span></code></a></p>
<p>A sequence of time-tagged rotations, enabling interpolation between them.
Uses scipy.spatial.transform.Slerp for interpolation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>rot</strong> (<a class="reference internal" href="#astrix.spatial.Rotation" title="astrix.spatial.Rotation"><em>Rotation</em></a><em> | </em><em>list</em><em> of </em><a class="reference internal" href="#astrix.spatial.Rotation" title="astrix.spatial.Rotation"><em>Rotation</em></a>) – A scipy Rotation object containing multiple rotations, or a list of such objects.
If a list is provided, all elements must be scipy Rotation objects.</p></li>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.html#astrix.Time" title="astrix.Time"><em>Time</em></a>) – A Time object with time instances corresponding to each rotation.
Must be the same length as the number of rotations and strictly increasing.</p></li>
<li><p><strong>backend</strong> (<em>BackendArg</em><em>, </em><em>optional</em>) – Array backend to use (numpy, jax, etc.). Defaults to numpy.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">astrix</span><span class="w"> </span><span class="kn">import</span> <span class="n">Time</span><span class="p">,</span> <span class="n">RotationSequence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timezone</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">Time</span><span class="o">.</span><span class="n">from_datetime</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rots</span> <span class="o">=</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;xyz&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>        <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>        <span class="p">[</span><span class="mi">180</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">],</span>
<span class="gp">... </span>    <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rot_seq</span> <span class="o">=</span> <span class="n">RotationSequence</span><span class="p">(</span><span class="n">rots</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">interp_rot</span> <span class="o">=</span> <span class="n">rot_seq</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Time</span><span class="o">.</span><span class="n">from_datetime</span><span class="p">(</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">))</span>
<span class="gp">... </span><span class="p">)</span>  <span class="c1"># Interpolate to halfway between first and second rotation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interp_rot</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>  <span class="c1"># Get interpolated rotation as Euler angles</span>
<span class="go">array([[45.,  0.,  0.]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.RotationSequence.convert_to">
<span class="sig-name descname"><span class="pre">convert_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backend</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/rotation.html#RotationSequence.convert_to"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.RotationSequence.convert_to" title="Link to this definition">¶</a></dt>
<dd><p>Convert the RotationSequence object to a different backend.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.rotation.html#astrix.spatial.rotation.RotationSequence" title="astrix.spatial.rotation.RotationSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotationSequence</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>backend</strong> (<em>str</em><em> | </em><em>Any</em><em> | </em><em>None</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.RotationSequence.downsample">
<span class="sig-name descname"><span class="pre">downsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt_max</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/rotation.html#RotationSequence.downsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.RotationSequence.downsample" title="Link to this definition">¶</a></dt>
<dd><p>Downsample the rotation sequence to a coarser time resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dt_max</strong> (<em>float</em>) – Desired maximum time step in seconds for downsampling.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new RotationSequence object with downsampled rotations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#astrix.spatial.RotationSequence" title="astrix.spatial.RotationSequence">RotationSequence</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.RotationSequence.interp">
<span class="sig-name descname"><span class="pre">interp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/rotation.html#RotationSequence.interp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.RotationSequence.interp" title="Link to this definition">¶</a></dt>
<dd><p>Interpolate the rotation sequence at the given times to return Rotation(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><em>Time</em></a>)</p></li>
<li><p><strong>check_bounds</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.RotationSequence.rots">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">rots</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><span class="pre">Rotation</span></a></span><a class="headerlink" href="#astrix.spatial.RotationSequence.rots" title="Link to this definition">¶</a></dt>
<dd><p>Get the underlying scipy Rotation object containing all rotations.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.RotationSequence.time">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">time</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><span class="pre">Time</span></a></span><a class="headerlink" href="#astrix.spatial.RotationSequence.time" title="Link to this definition">¶</a></dt>
<dd><p>Get the Time object associated with the rotation sequence.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="astrix.spatial.Velocity">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">Velocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_xp</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Velocity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Velocity" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Velocity vector(s) in ECEF coordinates (vx, vy, vz) in m/s.
Associated with a Time object for the time instances of the velocities.
Internal use only, typically created from Path objects.
No data validation is performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>vec</strong> (<em>Array</em>) – Velocity vectors in ECEF coordinates (vx, vy, vz) in m/s. Shape (n, 3).</p></li>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.html#astrix.Time" title="astrix.Time"><em>Time</em></a>) – Time object associated with the velocities. Length must match number of velocity vectors.</p></li>
<li><p><strong>backend</strong> (<em>BackendArg</em><em>, </em><em>optional</em>) – Array backend to use (numpy, jax, etc.). Defaults to numpy.</p></li>
<li><p><strong>_xp</strong> (<em>Any</em>)</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Velocity objects are typically created from Path objects.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">astrix</span><span class="w"> </span><span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Time</span><span class="p">,</span> <span class="n">Path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timezone</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">times</span> <span class="o">=</span> <span class="n">Time</span><span class="o">.</span><span class="n">from_datetime</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">datetime</span><span class="p">(</span><span class="mi">2025</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">datetime</span><span class="p">(</span><span class="mi">2025</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">datetime</span><span class="p">(</span><span class="mi">2025</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">),</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">Point</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="n">Point</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mf">3.8</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="n">Point</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">vel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span><span class="o">.</span><span class="n">magnitude</span>
<span class="go">array([1.91049732, 2.29128785, 2.6925824])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Velocity.from_data">
<span class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">from_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Velocity.from_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Velocity.from_data" title="Link to this definition">¶</a></dt>
<dd><p>Create a Velocity object from velocity vector array and Time object.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity" title="astrix.spatial.location.Velocity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Velocity</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul>
<li><p><strong>vec</strong> (<em>Buffer</em><em> | </em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><em>dtype</em><em>[</em><em>Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>_NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em>)</p></li>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><em>Time</em></a>)</p></li>
<li><p><strong>backend</strong> (<em>str</em><em> | </em><em>Any</em><em> | </em><em>None</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Velocity.convert_to">
<span class="sig-name descname"><span class="pre">convert_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backend</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Velocity.convert_to"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Velocity.convert_to" title="Link to this definition">¶</a></dt>
<dd><p>Convert the Velocity object to a different backend.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity" title="astrix.spatial.location.Velocity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Velocity</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>backend</strong> (<em>str</em><em> | </em><em>Any</em><em> | </em><em>None</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Velocity.interp">
<span class="sig-name descname"><span class="pre">interp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Velocity.interp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Velocity.interp" title="Link to this definition">¶</a></dt>
<dd><p>Interpolate the Velocity to the given times using the specified method.
Currently only ‘linear’ interpolation is supported.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity" title="astrix.spatial.location.Velocity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Velocity</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul>
<li><p><strong>time</strong> (<a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><em>Time</em></a>)</p></li>
<li><p><strong>method</strong> (<em>str</em>)</p></li>
<li><p><strong>check_bounds</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="astrix.spatial.Velocity.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rot</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/astrix/spatial/location.html#Velocity.rotate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#astrix.spatial.Velocity.rotate" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity" title="astrix.spatial.location.Velocity"><code class="xref py py-class docutils literal notranslate"><span class="pre">Velocity</span></code></a></span></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rot</strong> (<a class="reference internal" href="#astrix.spatial.Rotation" title="scipy.spatial.transform._rotation.Rotation"><em>Rotation</em></a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Velocity.acc">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">acc</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration" title="astrix.spatial.location.Acceleration"><span class="pre">Acceleration</span></a></span><a class="headerlink" href="#astrix.spatial.Velocity.acc" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the acceleration from the velocity using central differences.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Velocity.backend">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">backend</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">str</span></span><a class="headerlink" href="#astrix.spatial.Velocity.backend" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Velocity.magnitude">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">magnitude</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Any</span></span><a class="headerlink" href="#astrix.spatial.Velocity.magnitude" title="Link to this definition">¶</a></dt>
<dd><p>Get the velocity magnitude in m/s.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="astrix.spatial.Velocity.time">
<span class="sig-name descname"><span class="pre">time</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="astrix.time.html#astrix.time.Time" title="astrix.time.Time"><span class="pre">Time</span></a></span><a class="headerlink" href="#astrix.spatial.Velocity.time" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="astrix.spatial.Velocity.unit">
<span class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">unit</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Any</span></span><a class="headerlink" href="#astrix.spatial.Velocity.unit" title="Link to this definition">¶</a></dt>
<dd><p>Get the unit velocity vector.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="astrix.spatial.Velocity.vec">
<span class="sig-name descname"><span class="pre">vec</span></span><span class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Any</span></span><a class="headerlink" href="#astrix.spatial.Velocity.vec" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="astrix.spatial.frame.html">astrix.spatial.frame module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame"><code class="docutils literal notranslate"><span class="pre">Frame</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.convert_to"><code class="docutils literal notranslate"><span class="pre">Frame.convert_to()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.index_loc"><code class="docutils literal notranslate"><span class="pre">Frame.index_loc()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.index_rot"><code class="docutils literal notranslate"><span class="pre">Frame.index_rot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.interp_loc"><code class="docutils literal notranslate"><span class="pre">Frame.interp_loc()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.interp_rot"><code class="docutils literal notranslate"><span class="pre">Frame.interp_rot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.replace_rot"><code class="docutils literal notranslate"><span class="pre">Frame.replace_rot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.sample_at_time"><code class="docutils literal notranslate"><span class="pre">Frame.sample_at_time()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.backend"><code class="docutils literal notranslate"><span class="pre">Frame.backend</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.has_ref"><code class="docutils literal notranslate"><span class="pre">Frame.has_ref</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.is_static"><code class="docutils literal notranslate"><span class="pre">Frame.is_static</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.loc"><code class="docutils literal notranslate"><span class="pre">Frame.loc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.name"><code class="docutils literal notranslate"><span class="pre">Frame.name</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.name_chain"><code class="docutils literal notranslate"><span class="pre">Frame.name_chain</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.path"><code class="docutils literal notranslate"><span class="pre">Frame.path</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.point"><code class="docutils literal notranslate"><span class="pre">Frame.point</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.rel_rot"><code class="docutils literal notranslate"><span class="pre">Frame.rel_rot</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.time_bounds"><code class="docutils literal notranslate"><span class="pre">Frame.time_bounds</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.Frame.time_group"><code class="docutils literal notranslate"><span class="pre">Frame.time_group</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.heading_frame"><code class="docutils literal notranslate"><span class="pre">heading_frame()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.ned_frame"><code class="docutils literal notranslate"><span class="pre">ned_frame()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.frame.html#astrix.spatial.frame.velocity_frame"><code class="docutils literal notranslate"><span class="pre">velocity_frame()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="astrix.spatial.location.html">astrix.spatial.location module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration"><code class="docutils literal notranslate"><span class="pre">Acceleration</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration.from_data"><code class="docutils literal notranslate"><span class="pre">Acceleration.from_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration.convert_to"><code class="docutils literal notranslate"><span class="pre">Acceleration.convert_to()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration.interp"><code class="docutils literal notranslate"><span class="pre">Acceleration.interp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration.rotate"><code class="docutils literal notranslate"><span class="pre">Acceleration.rotate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration.backend"><code class="docutils literal notranslate"><span class="pre">Acceleration.backend</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration.magnitude"><code class="docutils literal notranslate"><span class="pre">Acceleration.magnitude</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration.time"><code class="docutils literal notranslate"><span class="pre">Acceleration.time</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration.unit"><code class="docutils literal notranslate"><span class="pre">Acceleration.unit</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Acceleration.vec"><code class="docutils literal notranslate"><span class="pre">Acceleration.vec</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Location"><code class="docutils literal notranslate"><span class="pre">Location</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Location.convert_to"><code class="docutils literal notranslate"><span class="pre">Location.convert_to()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Location.backend"><code class="docutils literal notranslate"><span class="pre">Location.backend</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Location.ecef"><code class="docutils literal notranslate"><span class="pre">Location.ecef</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Location.geodet"><code class="docutils literal notranslate"><span class="pre">Location.geodet</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Location.is_singular"><code class="docutils literal notranslate"><span class="pre">Location.is_singular</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Location.time"><code class="docutils literal notranslate"><span class="pre">Location.time</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path"><code class="docutils literal notranslate"><span class="pre">Path</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path.convert_to"><code class="docutils literal notranslate"><span class="pre">Path.convert_to()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path.downsample"><code class="docutils literal notranslate"><span class="pre">Path.downsample()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path.interp"><code class="docutils literal notranslate"><span class="pre">Path.interp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path.time_at_alt"><code class="docutils literal notranslate"><span class="pre">Path.time_at_alt()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path.truncate"><code class="docutils literal notranslate"><span class="pre">Path.truncate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path.acc"><code class="docutils literal notranslate"><span class="pre">Path.acc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path.end_time"><code class="docutils literal notranslate"><span class="pre">Path.end_time</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path.is_singular"><code class="docutils literal notranslate"><span class="pre">Path.is_singular</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path.points"><code class="docutils literal notranslate"><span class="pre">Path.points</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path.start_time"><code class="docutils literal notranslate"><span class="pre">Path.start_time</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Path.vel"><code class="docutils literal notranslate"><span class="pre">Path.vel</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point"><code class="docutils literal notranslate"><span class="pre">Point</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point.from_geodet"><code class="docutils literal notranslate"><span class="pre">Point.from_geodet()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point.from_list"><code class="docutils literal notranslate"><span class="pre">Point.from_list()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point.convert_to"><code class="docutils literal notranslate"><span class="pre">Point.convert_to()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point.has_time"><code class="docutils literal notranslate"><span class="pre">Point.has_time</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Point.is_singular"><code class="docutils literal notranslate"><span class="pre">Point.is_singular</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity"><code class="docutils literal notranslate"><span class="pre">Velocity</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity.from_data"><code class="docutils literal notranslate"><span class="pre">Velocity.from_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity.convert_to"><code class="docutils literal notranslate"><span class="pre">Velocity.convert_to()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity.interp"><code class="docutils literal notranslate"><span class="pre">Velocity.interp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity.rotate"><code class="docutils literal notranslate"><span class="pre">Velocity.rotate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity.acc"><code class="docutils literal notranslate"><span class="pre">Velocity.acc</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity.backend"><code class="docutils literal notranslate"><span class="pre">Velocity.backend</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity.magnitude"><code class="docutils literal notranslate"><span class="pre">Velocity.magnitude</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity.time"><code class="docutils literal notranslate"><span class="pre">Velocity.time</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity.unit"><code class="docutils literal notranslate"><span class="pre">Velocity.unit</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.location.html#astrix.spatial.location.Velocity.vec"><code class="docutils literal notranslate"><span class="pre">Velocity.vec</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="astrix.spatial.ray.html">astrix.spatial.ray module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray"><code class="docutils literal notranslate"><span class="pre">Ray</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.from_az_el"><code class="docutils literal notranslate"><span class="pre">Ray.from_az_el()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.from_camera"><code class="docutils literal notranslate"><span class="pre">Ray.from_camera()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.from_points"><code class="docutils literal notranslate"><span class="pre">Ray.from_points()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.from_target_frame"><code class="docutils literal notranslate"><span class="pre">Ray.from_target_frame()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.convert_to"><code class="docutils literal notranslate"><span class="pre">Ray.convert_to()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.correct_refraction"><code class="docutils literal notranslate"><span class="pre">Ray.correct_refraction()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.interp"><code class="docutils literal notranslate"><span class="pre">Ray.interp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.project_to_cam"><code class="docutils literal notranslate"><span class="pre">Ray.project_to_cam()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.replace_frame"><code class="docutils literal notranslate"><span class="pre">Ray.replace_frame()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.to_ecef"><code class="docutils literal notranslate"><span class="pre">Ray.to_ecef()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.to_frame"><code class="docutils literal notranslate"><span class="pre">Ray.to_frame()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.to_ned"><code class="docutils literal notranslate"><span class="pre">Ray.to_ned()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.az_el"><code class="docutils literal notranslate"><span class="pre">Ray.az_el</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.backend"><code class="docutils literal notranslate"><span class="pre">Ray.backend</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.frame"><code class="docutils literal notranslate"><span class="pre">Ray.frame</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.has_time"><code class="docutils literal notranslate"><span class="pre">Ray.has_time</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.origin_points"><code class="docutils literal notranslate"><span class="pre">Ray.origin_points</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.origin_rel"><code class="docutils literal notranslate"><span class="pre">Ray.origin_rel</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.time"><code class="docutils literal notranslate"><span class="pre">Ray.time</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.total_angle"><code class="docutils literal notranslate"><span class="pre">Ray.total_angle</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.unit_ecef"><code class="docutils literal notranslate"><span class="pre">Ray.unit_ecef</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.ray.html#astrix.spatial.ray.Ray.unit_rel"><code class="docutils literal notranslate"><span class="pre">Ray.unit_rel</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="astrix.spatial.rotation.html">astrix.spatial.rotation module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.rotation.html#astrix.spatial.rotation.RotationLike"><code class="docutils literal notranslate"><span class="pre">RotationLike</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.rotation.html#astrix.spatial.rotation.RotationLike.convert_to"><code class="docutils literal notranslate"><span class="pre">RotationLike.convert_to()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.rotation.html#astrix.spatial.rotation.RotationLike.interp"><code class="docutils literal notranslate"><span class="pre">RotationLike.interp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.rotation.html#astrix.spatial.rotation.RotationLike.backend"><code class="docutils literal notranslate"><span class="pre">RotationLike.backend</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.rotation.html#astrix.spatial.rotation.RotationLike.time"><code class="docutils literal notranslate"><span class="pre">RotationLike.time</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="astrix.spatial.rotation.html#astrix.spatial.rotation.RotationSequence"><code class="docutils literal notranslate"><span class="pre">RotationSequence</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.rotation.html#astrix.spatial.rotation.RotationSequence.convert_to"><code class="docutils literal notranslate"><span class="pre">RotationSequence.convert_to()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.rotation.html#astrix.spatial.rotation.RotationSequence.downsample"><code class="docutils literal notranslate"><span class="pre">RotationSequence.downsample()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.rotation.html#astrix.spatial.rotation.RotationSequence.interp"><code class="docutils literal notranslate"><span class="pre">RotationSequence.interp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.rotation.html#astrix.spatial.rotation.RotationSequence.rots"><code class="docutils literal notranslate"><span class="pre">RotationSequence.rots</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="astrix.spatial.rotation.html#astrix.spatial.rotation.RotationSequence.time"><code class="docutils literal notranslate"><span class="pre">RotationSequence.time</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, Andrew Lock
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">astrix.spatial package</a><ul>
<li><a class="reference internal" href="#astrix.spatial.Acceleration"><code class="docutils literal notranslate"><span class="pre">Acceleration</span></code></a><ul>
<li><a class="reference internal" href="#astrix.spatial.Acceleration.from_data"><code class="docutils literal notranslate"><span class="pre">Acceleration.from_data()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Acceleration.convert_to"><code class="docutils literal notranslate"><span class="pre">Acceleration.convert_to()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Acceleration.interp"><code class="docutils literal notranslate"><span class="pre">Acceleration.interp()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Acceleration.rotate"><code class="docutils literal notranslate"><span class="pre">Acceleration.rotate()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Acceleration.backend"><code class="docutils literal notranslate"><span class="pre">Acceleration.backend</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Acceleration.magnitude"><code class="docutils literal notranslate"><span class="pre">Acceleration.magnitude</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Acceleration.time"><code class="docutils literal notranslate"><span class="pre">Acceleration.time</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Acceleration.unit"><code class="docutils literal notranslate"><span class="pre">Acceleration.unit</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Acceleration.vec"><code class="docutils literal notranslate"><span class="pre">Acceleration.vec</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#astrix.spatial.Frame"><code class="docutils literal notranslate"><span class="pre">Frame</span></code></a><ul>
<li><a class="reference internal" href="#astrix.spatial.Frame.convert_to"><code class="docutils literal notranslate"><span class="pre">Frame.convert_to()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.index_loc"><code class="docutils literal notranslate"><span class="pre">Frame.index_loc()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.index_rot"><code class="docutils literal notranslate"><span class="pre">Frame.index_rot()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.interp_loc"><code class="docutils literal notranslate"><span class="pre">Frame.interp_loc()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.interp_rot"><code class="docutils literal notranslate"><span class="pre">Frame.interp_rot()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.replace_rot"><code class="docutils literal notranslate"><span class="pre">Frame.replace_rot()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.sample_at_time"><code class="docutils literal notranslate"><span class="pre">Frame.sample_at_time()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.backend"><code class="docutils literal notranslate"><span class="pre">Frame.backend</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.has_ref"><code class="docutils literal notranslate"><span class="pre">Frame.has_ref</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.is_static"><code class="docutils literal notranslate"><span class="pre">Frame.is_static</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.loc"><code class="docutils literal notranslate"><span class="pre">Frame.loc</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.name"><code class="docutils literal notranslate"><span class="pre">Frame.name</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.name_chain"><code class="docutils literal notranslate"><span class="pre">Frame.name_chain</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.path"><code class="docutils literal notranslate"><span class="pre">Frame.path</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.point"><code class="docutils literal notranslate"><span class="pre">Frame.point</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.rel_rot"><code class="docutils literal notranslate"><span class="pre">Frame.rel_rot</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.time_bounds"><code class="docutils literal notranslate"><span class="pre">Frame.time_bounds</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Frame.time_group"><code class="docutils literal notranslate"><span class="pre">Frame.time_group</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#astrix.spatial.Path"><code class="docutils literal notranslate"><span class="pre">Path</span></code></a><ul>
<li><a class="reference internal" href="#astrix.spatial.Path.convert_to"><code class="docutils literal notranslate"><span class="pre">Path.convert_to()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Path.downsample"><code class="docutils literal notranslate"><span class="pre">Path.downsample()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Path.interp"><code class="docutils literal notranslate"><span class="pre">Path.interp()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Path.time_at_alt"><code class="docutils literal notranslate"><span class="pre">Path.time_at_alt()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Path.truncate"><code class="docutils literal notranslate"><span class="pre">Path.truncate()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Path.acc"><code class="docutils literal notranslate"><span class="pre">Path.acc</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Path.end_time"><code class="docutils literal notranslate"><span class="pre">Path.end_time</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Path.is_singular"><code class="docutils literal notranslate"><span class="pre">Path.is_singular</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Path.points"><code class="docutils literal notranslate"><span class="pre">Path.points</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Path.start_time"><code class="docutils literal notranslate"><span class="pre">Path.start_time</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Path.vel"><code class="docutils literal notranslate"><span class="pre">Path.vel</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#astrix.spatial.Point"><code class="docutils literal notranslate"><span class="pre">Point</span></code></a><ul>
<li><a class="reference internal" href="#astrix.spatial.Point.from_geodet"><code class="docutils literal notranslate"><span class="pre">Point.from_geodet()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Point.from_list"><code class="docutils literal notranslate"><span class="pre">Point.from_list()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Point.convert_to"><code class="docutils literal notranslate"><span class="pre">Point.convert_to()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Point.has_time"><code class="docutils literal notranslate"><span class="pre">Point.has_time</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Point.is_singular"><code class="docutils literal notranslate"><span class="pre">Point.is_singular</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#astrix.spatial.Ray"><code class="docutils literal notranslate"><span class="pre">Ray</span></code></a><ul>
<li><a class="reference internal" href="#astrix.spatial.Ray.from_az_el"><code class="docutils literal notranslate"><span class="pre">Ray.from_az_el()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.from_camera"><code class="docutils literal notranslate"><span class="pre">Ray.from_camera()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.from_points"><code class="docutils literal notranslate"><span class="pre">Ray.from_points()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.from_target_frame"><code class="docutils literal notranslate"><span class="pre">Ray.from_target_frame()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.convert_to"><code class="docutils literal notranslate"><span class="pre">Ray.convert_to()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.correct_refraction"><code class="docutils literal notranslate"><span class="pre">Ray.correct_refraction()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.interp"><code class="docutils literal notranslate"><span class="pre">Ray.interp()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.project_to_cam"><code class="docutils literal notranslate"><span class="pre">Ray.project_to_cam()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.replace_frame"><code class="docutils literal notranslate"><span class="pre">Ray.replace_frame()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.to_ecef"><code class="docutils literal notranslate"><span class="pre">Ray.to_ecef()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.to_frame"><code class="docutils literal notranslate"><span class="pre">Ray.to_frame()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.to_ned"><code class="docutils literal notranslate"><span class="pre">Ray.to_ned()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.az_el"><code class="docutils literal notranslate"><span class="pre">Ray.az_el</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.backend"><code class="docutils literal notranslate"><span class="pre">Ray.backend</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.frame"><code class="docutils literal notranslate"><span class="pre">Ray.frame</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.has_time"><code class="docutils literal notranslate"><span class="pre">Ray.has_time</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.origin_points"><code class="docutils literal notranslate"><span class="pre">Ray.origin_points</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.origin_rel"><code class="docutils literal notranslate"><span class="pre">Ray.origin_rel</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.time"><code class="docutils literal notranslate"><span class="pre">Ray.time</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.total_angle"><code class="docutils literal notranslate"><span class="pre">Ray.total_angle</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.unit_ecef"><code class="docutils literal notranslate"><span class="pre">Ray.unit_ecef</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Ray.unit_rel"><code class="docutils literal notranslate"><span class="pre">Ray.unit_rel</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#astrix.spatial.Rotation"><code class="docutils literal notranslate"><span class="pre">Rotation</span></code></a><ul>
<li><a class="reference internal" href="#astrix.spatial.Rotation.single"><code class="docutils literal notranslate"><span class="pre">Rotation.single</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.__len__"><code class="docutils literal notranslate"><span class="pre">Rotation.__len__()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.from_quat"><code class="docutils literal notranslate"><span class="pre">Rotation.from_quat()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.from_matrix"><code class="docutils literal notranslate"><span class="pre">Rotation.from_matrix()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.from_rotvec"><code class="docutils literal notranslate"><span class="pre">Rotation.from_rotvec()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.from_mrp"><code class="docutils literal notranslate"><span class="pre">Rotation.from_mrp()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.from_euler"><code class="docutils literal notranslate"><span class="pre">Rotation.from_euler()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.from_davenport"><code class="docutils literal notranslate"><span class="pre">Rotation.from_davenport()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.as_quat"><code class="docutils literal notranslate"><span class="pre">Rotation.as_quat()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.as_matrix"><code class="docutils literal notranslate"><span class="pre">Rotation.as_matrix()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.as_rotvec"><code class="docutils literal notranslate"><span class="pre">Rotation.as_rotvec()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.as_mrp"><code class="docutils literal notranslate"><span class="pre">Rotation.as_mrp()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.as_euler"><code class="docutils literal notranslate"><span class="pre">Rotation.as_euler()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.as_davenport"><code class="docutils literal notranslate"><span class="pre">Rotation.as_davenport()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.concatenate"><code class="docutils literal notranslate"><span class="pre">Rotation.concatenate()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.apply"><code class="docutils literal notranslate"><span class="pre">Rotation.apply()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.__mul__"><code class="docutils literal notranslate"><span class="pre">Rotation.__mul__()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.__pow__"><code class="docutils literal notranslate"><span class="pre">Rotation.__pow__()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.inv"><code class="docutils literal notranslate"><span class="pre">Rotation.inv()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.magnitude"><code class="docutils literal notranslate"><span class="pre">Rotation.magnitude()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.approx_equal"><code class="docutils literal notranslate"><span class="pre">Rotation.approx_equal()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.mean"><code class="docutils literal notranslate"><span class="pre">Rotation.mean()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.reduce"><code class="docutils literal notranslate"><span class="pre">Rotation.reduce()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.create_group"><code class="docutils literal notranslate"><span class="pre">Rotation.create_group()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.__getitem__"><code class="docutils literal notranslate"><span class="pre">Rotation.__getitem__()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.identity"><code class="docutils literal notranslate"><span class="pre">Rotation.identity()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.random"><code class="docutils literal notranslate"><span class="pre">Rotation.random()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.align_vectors"><code class="docutils literal notranslate"><span class="pre">Rotation.align_vectors()</span></code></a></li>
<li><a class="reference internal" href="#id0"><code class="docutils literal notranslate"><span class="pre">Rotation.create_group()</span></code></a></li>
<li><a class="reference internal" href="#id2"><code class="docutils literal notranslate"><span class="pre">Rotation.align_vectors()</span></code></a></li>
<li><a class="reference internal" href="#id15"><code class="docutils literal notranslate"><span class="pre">Rotation.concatenate()</span></code></a></li>
<li><a class="reference internal" href="#id16"><code class="docutils literal notranslate"><span class="pre">Rotation.from_davenport()</span></code></a></li>
<li><a class="reference internal" href="#id21"><code class="docutils literal notranslate"><span class="pre">Rotation.from_euler()</span></code></a></li>
<li><a class="reference internal" href="#id24"><code class="docutils literal notranslate"><span class="pre">Rotation.from_matrix()</span></code></a></li>
<li><a class="reference internal" href="#id31"><code class="docutils literal notranslate"><span class="pre">Rotation.from_mrp()</span></code></a></li>
<li><a class="reference internal" href="#id34"><code class="docutils literal notranslate"><span class="pre">Rotation.from_quat()</span></code></a></li>
<li><a class="reference internal" href="#id39"><code class="docutils literal notranslate"><span class="pre">Rotation.from_rotvec()</span></code></a></li>
<li><a class="reference internal" href="#id42"><code class="docutils literal notranslate"><span class="pre">Rotation.identity()</span></code></a></li>
<li><a class="reference internal" href="#id43"><code class="docutils literal notranslate"><span class="pre">Rotation.random()</span></code></a></li>
<li><a class="reference internal" href="#id44"><code class="docutils literal notranslate"><span class="pre">Rotation.apply()</span></code></a></li>
<li><a class="reference internal" href="#id45"><code class="docutils literal notranslate"><span class="pre">Rotation.approx_equal()</span></code></a></li>
<li><a class="reference internal" href="#id46"><code class="docutils literal notranslate"><span class="pre">Rotation.as_davenport()</span></code></a></li>
<li><a class="reference internal" href="#id53"><code class="docutils literal notranslate"><span class="pre">Rotation.as_euler()</span></code></a></li>
<li><a class="reference internal" href="#id61"><code class="docutils literal notranslate"><span class="pre">Rotation.as_matrix()</span></code></a></li>
<li><a class="reference internal" href="#id64"><code class="docutils literal notranslate"><span class="pre">Rotation.as_mrp()</span></code></a></li>
<li><a class="reference internal" href="#id67"><code class="docutils literal notranslate"><span class="pre">Rotation.as_quat()</span></code></a></li>
<li><a class="reference internal" href="#id70"><code class="docutils literal notranslate"><span class="pre">Rotation.as_rotvec()</span></code></a></li>
<li><a class="reference internal" href="#id73"><code class="docutils literal notranslate"><span class="pre">Rotation.inv()</span></code></a></li>
<li><a class="reference internal" href="#id74"><code class="docutils literal notranslate"><span class="pre">Rotation.magnitude()</span></code></a></li>
<li><a class="reference internal" href="#id75"><code class="docutils literal notranslate"><span class="pre">Rotation.mean()</span></code></a></li>
<li><a class="reference internal" href="#id78"><code class="docutils literal notranslate"><span class="pre">Rotation.reduce()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Rotation.shape"><code class="docutils literal notranslate"><span class="pre">Rotation.shape</span></code></a></li>
<li><a class="reference internal" href="#id79"><code class="docutils literal notranslate"><span class="pre">Rotation.single</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#astrix.spatial.RotationSequence"><code class="docutils literal notranslate"><span class="pre">RotationSequence</span></code></a><ul>
<li><a class="reference internal" href="#astrix.spatial.RotationSequence.convert_to"><code class="docutils literal notranslate"><span class="pre">RotationSequence.convert_to()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.RotationSequence.downsample"><code class="docutils literal notranslate"><span class="pre">RotationSequence.downsample()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.RotationSequence.interp"><code class="docutils literal notranslate"><span class="pre">RotationSequence.interp()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.RotationSequence.rots"><code class="docutils literal notranslate"><span class="pre">RotationSequence.rots</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.RotationSequence.time"><code class="docutils literal notranslate"><span class="pre">RotationSequence.time</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#astrix.spatial.Velocity"><code class="docutils literal notranslate"><span class="pre">Velocity</span></code></a><ul>
<li><a class="reference internal" href="#astrix.spatial.Velocity.from_data"><code class="docutils literal notranslate"><span class="pre">Velocity.from_data()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Velocity.convert_to"><code class="docutils literal notranslate"><span class="pre">Velocity.convert_to()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Velocity.interp"><code class="docutils literal notranslate"><span class="pre">Velocity.interp()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Velocity.rotate"><code class="docutils literal notranslate"><span class="pre">Velocity.rotate()</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Velocity.acc"><code class="docutils literal notranslate"><span class="pre">Velocity.acc</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Velocity.backend"><code class="docutils literal notranslate"><span class="pre">Velocity.backend</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Velocity.magnitude"><code class="docutils literal notranslate"><span class="pre">Velocity.magnitude</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Velocity.time"><code class="docutils literal notranslate"><span class="pre">Velocity.time</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Velocity.unit"><code class="docutils literal notranslate"><span class="pre">Velocity.unit</span></code></a></li>
<li><a class="reference internal" href="#astrix.spatial.Velocity.vec"><code class="docutils literal notranslate"><span class="pre">Velocity.vec</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=8a448e45"></script>
    <script src="../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    </body>
</html>