<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../../genindex.html"><link rel="search" title="Search" href="../../../../search.html">

    <!-- Generated with Sphinx 9.1.0 and Furo 2025.12.19 -->
        <title>scipy.spatial.transform._rotation - AsTrIX documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=d111a655" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo.css?v=7bdb33bb" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo-extensions.css?v=8dab3a3b" />
    
    


<style>
  body {
    --color-code-background: #f2f2f2;
  --color-code-foreground: #1e1e1e;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../../index.html"><div class="brand">AsTrIX  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../../index.html">
  
  <span class="sidebar-brand-text">AsTrIX  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../examples.html">Examples</a><input aria-label="Toggle navigation of Examples" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../examples/example_1.html">Example 1 placeholder</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../api/index.html">API Reference</a><input aria-label="Toggle navigation of API Reference" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/astrix.time.html">astrix.time module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/astrix.spatial.location.html">astrix.spatial.location module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/astrix.spatial.frame.html">astrix.spatial.frame module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/astrix.spatial.ray.html">astrix.spatial.ray module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/astrix.spatial.rotation.html">astrix.spatial.rotation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/astrix.project.html">astrix.project module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/astrix.generic.html">astrix.generic module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../api/astrix.planning.html">astrix.planning module</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for scipy.spatial.transform._rotation</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">types</span><span class="w"> </span><span class="kn">import</span> <span class="n">EllipsisType</span><span class="p">,</span> <span class="n">ModuleType</span><span class="p">,</span> <span class="n">NotImplementedType</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.spatial.transform._rotation_cy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cython_backend</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.spatial.transform._rotation_xp</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xp_backend</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform._rotation_groups</span><span class="w"> </span><span class="kn">import</span> <span class="n">create_group</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy._lib._array_api</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">array_namespace</span><span class="p">,</span>
    <span class="n">Array</span><span class="p">,</span>
    <span class="n">is_numpy</span><span class="p">,</span>
    <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">is_lazy_array</span><span class="p">,</span>
    <span class="n">xp_capabilities</span><span class="p">,</span>
    <span class="n">xp_promote</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy._lib.array_api_compat</span><span class="w"> </span><span class="kn">import</span> <span class="n">device</span> <span class="k">as</span> <span class="n">xp_device</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy._lib.array_api_extra</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xpx</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy._lib._util</span><span class="w"> </span><span class="kn">import</span> <span class="n">_transition_to_rng</span><span class="p">,</span> <span class="n">broadcastable</span>

<span class="n">backend_registry</span> <span class="o">=</span> <span class="p">{</span><span class="n">array_namespace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span> <span class="n">cython_backend</span><span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">select_backend</span><span class="p">(</span><span class="n">xp</span><span class="p">:</span> <span class="n">ModuleType</span><span class="p">,</span> <span class="n">cython_compatible</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Select the backend for the given array library.</span>

<span class="sd">    We need this selection function because the Cython backend for numpy does not</span>
<span class="sd">    support quaternions of arbitrary dimensions. We therefore only use the Array API</span>
<span class="sd">    backend for numpy if we are dealing with rotations of more than one leading</span>
<span class="sd">    dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_numpy</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cython_compatible</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xp_backend</span>
    <span class="k">return</span> <span class="n">backend_registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">xp_backend</span><span class="p">)</span>


<span class="nd">@xp_capabilities</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_promote</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">xp</span><span class="p">:</span> <span class="n">ModuleType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Promote arrays to float64 for numpy, else according to the Array API spec.</span>

<span class="sd">    The return array dtype follows the following rules:</span>
<span class="sd">    - If quat is an ArrayLike or NumPy array, we always promote to float64</span>
<span class="sd">    - If quat is an Array from frameworks other than NumPy, we preserve the precision</span>
<span class="sd">      of the input array dtype.</span>

<span class="sd">    The first rule is required by the cython backend signatures that expect</span>
<span class="sd">    cython.double views. The second rule is necessary to promote non-floating arrays</span>
<span class="sd">    to the correct type in frameworks that may not support double precision (e.g.</span>
<span class="sd">    jax by default).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_numpy</span><span class="p">(</span><span class="n">xp</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),)</span>  <span class="c1"># Force float64 conversion</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">xp_promote</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">force_floating</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># One argument was passed  + the added empty array</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">xp_promote</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">force_floating</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span>


<div class="viewcode-block" id="Rotation">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Rotation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Rotation in 3 dimensions.</span>

<span class="sd">    This class provides an interface to initialize from and represent rotations</span>
<span class="sd">    with:</span>

<span class="sd">    - Quaternions</span>
<span class="sd">    - Rotation Matrices</span>
<span class="sd">    - Rotation Vectors</span>
<span class="sd">    - Modified Rodrigues Parameters</span>
<span class="sd">    - Euler Angles</span>
<span class="sd">    - Davenport Angles (Generalized Euler Angles)</span>

<span class="sd">    The following operations on rotations are supported:</span>

<span class="sd">    - Application on vectors</span>
<span class="sd">    - Rotation Composition</span>
<span class="sd">    - Rotation Inversion</span>
<span class="sd">    - Rotation Indexing</span>

<span class="sd">    A `Rotation` instance can contain a single rotation transform or rotations of</span>
<span class="sd">    multiple leading dimensions. E.g., it is possible to have an N-dimensional array of</span>
<span class="sd">    (N, M, K) rotations. When applied to other rotations or vectors, standard</span>
<span class="sd">    broadcasting rules apply.</span>

<span class="sd">    Indexing within a rotation is supported to access a subset of the rotations stored</span>
<span class="sd">    in a `Rotation` instance.</span>

<span class="sd">    To create `Rotation` objects use ``from_...`` methods (see examples below).</span>
<span class="sd">    ``Rotation(...)`` is not supposed to be instantiated directly.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    single</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __len__</span>
<span class="sd">    from_quat</span>
<span class="sd">    from_matrix</span>
<span class="sd">    from_rotvec</span>
<span class="sd">    from_mrp</span>
<span class="sd">    from_euler</span>
<span class="sd">    from_davenport</span>
<span class="sd">    as_quat</span>
<span class="sd">    as_matrix</span>
<span class="sd">    as_rotvec</span>
<span class="sd">    as_mrp</span>
<span class="sd">    as_euler</span>
<span class="sd">    as_davenport</span>
<span class="sd">    concatenate</span>
<span class="sd">    apply</span>
<span class="sd">    __mul__</span>
<span class="sd">    __pow__</span>
<span class="sd">    inv</span>
<span class="sd">    magnitude</span>
<span class="sd">    approx_equal</span>
<span class="sd">    mean</span>
<span class="sd">    reduce</span>
<span class="sd">    create_group</span>
<span class="sd">    __getitem__</span>
<span class="sd">    identity</span>
<span class="sd">    random</span>
<span class="sd">    align_vectors</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Slerp</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 1.2.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    A `Rotation` instance can be initialized in any of the above formats and</span>
<span class="sd">    converted to any of the others. The underlying object is independent of the</span>
<span class="sd">    representation used for initialization.</span>

<span class="sd">    Consider a counter-clockwise rotation of 90 degrees about the z-axis. This</span>
<span class="sd">    corresponds to the following quaternion (in scalar-last format):</span>

<span class="sd">    &gt;&gt;&gt; r = R.from_quat([0, 0, np.sin(np.pi/4), np.cos(np.pi/4)])</span>

<span class="sd">    The rotation can be expressed in any of the other formats:</span>

<span class="sd">    &gt;&gt;&gt; r.as_matrix()</span>
<span class="sd">    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="sd">    [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="sd">    [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])</span>
<span class="sd">    &gt;&gt;&gt; r.as_rotvec()</span>
<span class="sd">    array([0.        , 0.        , 1.57079633])</span>
<span class="sd">    &gt;&gt;&gt; r.as_euler(&#39;zyx&#39;, degrees=True)</span>
<span class="sd">    array([90.,  0.,  0.])</span>

<span class="sd">    The same rotation can be initialized using a rotation matrix:</span>

<span class="sd">    &gt;&gt;&gt; r = R.from_matrix([[0, -1, 0],</span>
<span class="sd">    ...                    [1, 0, 0],</span>
<span class="sd">    ...                    [0, 0, 1]])</span>

<span class="sd">    Representation in other formats:</span>

<span class="sd">    &gt;&gt;&gt; r.as_quat()</span>
<span class="sd">    array([0.        , 0.        , 0.70710678, 0.70710678])</span>
<span class="sd">    &gt;&gt;&gt; r.as_rotvec()</span>
<span class="sd">    array([0.        , 0.        , 1.57079633])</span>
<span class="sd">    &gt;&gt;&gt; r.as_euler(&#39;zyx&#39;, degrees=True)</span>
<span class="sd">    array([90.,  0.,  0.])</span>

<span class="sd">    The rotation vector corresponding to this rotation is given by:</span>

<span class="sd">    &gt;&gt;&gt; r = R.from_rotvec(np.pi/2 * np.array([0, 0, 1]))</span>

<span class="sd">    Representation in other formats:</span>

<span class="sd">    &gt;&gt;&gt; r.as_quat()</span>
<span class="sd">    array([0.        , 0.        , 0.70710678, 0.70710678])</span>
<span class="sd">    &gt;&gt;&gt; r.as_matrix()</span>
<span class="sd">    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="sd">           [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="sd">           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])</span>
<span class="sd">    &gt;&gt;&gt; r.as_euler(&#39;zyx&#39;, degrees=True)</span>
<span class="sd">    array([90.,  0.,  0.])</span>

<span class="sd">    The ``from_euler`` method is quite flexible in the range of input formats</span>
<span class="sd">    it supports. Here we initialize a single rotation about a single axis:</span>

<span class="sd">    &gt;&gt;&gt; r = R.from_euler(&#39;z&#39;, 90, degrees=True)</span>

<span class="sd">    Again, the object is representation independent and can be converted to any</span>
<span class="sd">    other format:</span>

<span class="sd">    &gt;&gt;&gt; r.as_quat()</span>
<span class="sd">    array([0.        , 0.        , 0.70710678, 0.70710678])</span>
<span class="sd">    &gt;&gt;&gt; r.as_matrix()</span>
<span class="sd">    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="sd">           [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="sd">           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])</span>
<span class="sd">    &gt;&gt;&gt; r.as_rotvec()</span>
<span class="sd">    array([0.        , 0.        , 1.57079633])</span>

<span class="sd">    It is also possible to initialize multiple rotations in a single instance</span>
<span class="sd">    using any of the ``from_...`` functions. Here we initialize a stack of 3</span>
<span class="sd">    rotations using the ``from_euler`` method:</span>

<span class="sd">    &gt;&gt;&gt; r = R.from_euler(&#39;zyx&#39;, [</span>
<span class="sd">    ... [90, 0, 0],</span>
<span class="sd">    ... [0, 45, 0],</span>
<span class="sd">    ... [45, 60, 30]], degrees=True)</span>

<span class="sd">    The other representations also now return a stack of 3 rotations. For</span>
<span class="sd">    example:</span>

<span class="sd">    &gt;&gt;&gt; r.as_quat()</span>
<span class="sd">    array([[0.        , 0.        , 0.70710678, 0.70710678],</span>
<span class="sd">           [0.        , 0.38268343, 0.        , 0.92387953],</span>
<span class="sd">           [0.39190384, 0.36042341, 0.43967974, 0.72331741]])</span>

<span class="sd">    Applying the above rotations onto a vector:</span>

<span class="sd">    &gt;&gt;&gt; v = [1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; r.apply(v)</span>
<span class="sd">    array([[-2.        ,  1.        ,  3.        ],</span>
<span class="sd">           [ 2.82842712,  2.        ,  1.41421356],</span>
<span class="sd">           [ 2.24452282,  0.78093109,  2.89002836]])</span>

<span class="sd">    A `Rotation` instance can be indexed and sliced as if it were an ND array:</span>

<span class="sd">    &gt;&gt;&gt; r.as_quat()</span>
<span class="sd">    array([[0.        , 0.        , 0.70710678, 0.70710678],</span>
<span class="sd">           [0.        , 0.38268343, 0.        , 0.92387953],</span>
<span class="sd">           [0.39190384, 0.36042341, 0.43967974, 0.72331741]])</span>
<span class="sd">    &gt;&gt;&gt; p = r[0]</span>
<span class="sd">    &gt;&gt;&gt; p.as_matrix()</span>
<span class="sd">    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="sd">           [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="sd">           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])</span>
<span class="sd">    &gt;&gt;&gt; q = r[1:3]</span>
<span class="sd">    &gt;&gt;&gt; q.as_quat()</span>
<span class="sd">    array([[0.        , 0.38268343, 0.        , 0.92387953],</span>
<span class="sd">           [0.39190384, 0.36042341, 0.43967974, 0.72331741]])</span>

<span class="sd">    In fact it can be converted to numpy.array:</span>

<span class="sd">    &gt;&gt;&gt; r_array = np.asarray(r)</span>
<span class="sd">    &gt;&gt;&gt; r_array.shape</span>
<span class="sd">    (3,)</span>
<span class="sd">    &gt;&gt;&gt; r_array[0].as_matrix()</span>
<span class="sd">    array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="sd">           [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="sd">           [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])</span>

<span class="sd">    Multiple rotations can be composed using the ``*`` operator:</span>

<span class="sd">    &gt;&gt;&gt; r1 = R.from_euler(&#39;z&#39;, 90, degrees=True)</span>
<span class="sd">    &gt;&gt;&gt; r2 = R.from_rotvec([np.pi/4, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; v = [1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; r2.apply(r1.apply(v))</span>
<span class="sd">    array([-2.        , -1.41421356,  2.82842712])</span>
<span class="sd">    &gt;&gt;&gt; r3 = r2 * r1 # Note the order</span>
<span class="sd">    &gt;&gt;&gt; r3.apply(v)</span>
<span class="sd">    array([-2.        , -1.41421356,  2.82842712])</span>

<span class="sd">    A rotation can be composed with itself using the ``**`` operator:</span>

<span class="sd">    &gt;&gt;&gt; p = R.from_rotvec([1, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; q = p ** 2</span>
<span class="sd">    &gt;&gt;&gt; q.as_rotvec()</span>
<span class="sd">    array([2., 0., 0.])</span>

<span class="sd">    Finally, it is also possible to invert rotations:</span>

<span class="sd">    &gt;&gt;&gt; r1 = R.from_euler(&#39;z&#39;, [[90], [45]], degrees=True)</span>
<span class="sd">    &gt;&gt;&gt; r2 = r1.inv()</span>
<span class="sd">    &gt;&gt;&gt; r2.as_euler(&#39;zyx&#39;, degrees=True)</span>
<span class="sd">    array([[-90.,   0.,   0.],</span>
<span class="sd">           [-45.,   0.,   0.]])</span>

<span class="sd">    The following function can be used to plot rotations with Matplotlib by</span>
<span class="sd">    showing how they transform the standard x, y, z coordinate axes:</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; def plot_rotated_axes(ax, r, name=None, offset=(0, 0, 0), scale=1):</span>
<span class="sd">    ...     colors = (&quot;#FF6666&quot;, &quot;#005533&quot;, &quot;#1199EE&quot;)  # Colorblind-safe RGB</span>
<span class="sd">    ...     loc = np.array([offset, offset])</span>
<span class="sd">    ...     for i, (axis, c) in enumerate(zip((ax.xaxis, ax.yaxis, ax.zaxis),</span>
<span class="sd">    ...                                       colors)):</span>
<span class="sd">    ...         axlabel = axis.axis_name</span>
<span class="sd">    ...         axis.set_label_text(axlabel)</span>
<span class="sd">    ...         axis.label.set_color(c)</span>
<span class="sd">    ...         axis.line.set_color(c)</span>
<span class="sd">    ...         axis.set_tick_params(colors=c)</span>
<span class="sd">    ...         line = np.zeros((2, 3))</span>
<span class="sd">    ...         line[1, i] = scale</span>
<span class="sd">    ...         line_rot = r.apply(line)</span>
<span class="sd">    ...         line_plot = line_rot + loc</span>
<span class="sd">    ...         ax.plot(line_plot[:, 0], line_plot[:, 1], line_plot[:, 2], c)</span>
<span class="sd">    ...         text_loc = line[1]*1.2</span>
<span class="sd">    ...         text_loc_rot = r.apply(text_loc)</span>
<span class="sd">    ...         text_plot = text_loc_rot + loc[0]</span>
<span class="sd">    ...         ax.text(*text_plot, axlabel.upper(), color=c,</span>
<span class="sd">    ...                 va=&quot;center&quot;, ha=&quot;center&quot;)</span>
<span class="sd">    ...     ax.text(*offset, name, color=&quot;k&quot;, va=&quot;center&quot;, ha=&quot;center&quot;,</span>
<span class="sd">    ...             bbox={&quot;fc&quot;: &quot;w&quot;, &quot;alpha&quot;: 0.8, &quot;boxstyle&quot;: &quot;circle&quot;})</span>

<span class="sd">    Create three rotations - the identity and two Euler rotations using</span>
<span class="sd">    intrinsic and extrinsic conventions:</span>

<span class="sd">    &gt;&gt;&gt; r0 = R.identity()</span>
<span class="sd">    &gt;&gt;&gt; r1 = R.from_euler(&quot;ZYX&quot;, [90, -30, 0], degrees=True)  # intrinsic</span>
<span class="sd">    &gt;&gt;&gt; r2 = R.from_euler(&quot;zyx&quot;, [90, -30, 0], degrees=True)  # extrinsic</span>

<span class="sd">    Add all three rotations to a single plot:</span>

<span class="sd">    &gt;&gt;&gt; ax = plt.figure().add_subplot(projection=&quot;3d&quot;, proj_type=&quot;ortho&quot;)</span>
<span class="sd">    &gt;&gt;&gt; plot_rotated_axes(ax, r0, name=&quot;r0&quot;, offset=(0, 0, 0))</span>
<span class="sd">    &gt;&gt;&gt; plot_rotated_axes(ax, r1, name=&quot;r1&quot;, offset=(3, 0, 0))</span>
<span class="sd">    &gt;&gt;&gt; plot_rotated_axes(ax, r2, name=&quot;r2&quot;, offset=(6, 0, 0))</span>
<span class="sd">    &gt;&gt;&gt; _ = ax.annotate(</span>
<span class="sd">    ...     &quot;r0: Identity Rotation\\n&quot;</span>
<span class="sd">    ...     &quot;r1: Intrinsic Euler Rotation (ZYX)\\n&quot;</span>
<span class="sd">    ...     &quot;r2: Extrinsic Euler Rotation (zyx)&quot;,</span>
<span class="sd">    ...     xy=(0.6, 0.7), xycoords=&quot;axes fraction&quot;, ha=&quot;left&quot;</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; ax.set(xlim=(-1.25, 7.25), ylim=(-1.25, 1.25), zlim=(-1.25, 1.25))</span>
<span class="sd">    &gt;&gt;&gt; ax.set(xticks=range(-1, 8), yticks=[-1, 0, 1], zticks=[-1, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; ax.set_aspect(&quot;equal&quot;, adjustable=&quot;box&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax.figure.set_size_inches(6, 5)</span>
<span class="sd">    &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    Show the plot:</span>

<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    These examples serve as an overview into the `Rotation` class and highlight</span>
<span class="sd">    major functionalities. For more thorough examples of the range of input and</span>
<span class="sd">    output formats supported, consult the individual method&#39;s examples.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">quat</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">scalar_first</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">array_namespace</span><span class="p">(</span><span class="n">quat</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xp</span> <span class="o">=</span> <span class="n">xp</span>
        <span class="n">quat</span> <span class="o">=</span> <span class="n">_promote</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected `quat` to have shape (..., 4), got </span><span class="si">{</span><span class="n">quat</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Single NumPy quats or list of quats are accelerated by the cython backend.</span>
        <span class="c1"># This backend needs inputs with fixed ndim, so we always expand to 2D and</span>
        <span class="c1"># select the 0th element if quat was single to get the correct shape. For other</span>
        <span class="c1"># frameworks and quaternion tensors we use the generic array API backend.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_single</span> <span class="o">=</span> <span class="n">quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">is_numpy</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span><span class="p">:</span>
            <span class="n">quat</span> <span class="o">=</span> <span class="n">xpx</span><span class="o">.</span><span class="n">atleast_nd</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span> <span class="o">=</span> <span class="n">select_backend</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">cython_compatible</span><span class="o">=</span><span class="n">quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">:</span> <span class="n">Array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">from_quat</span><span class="p">(</span>
            <span class="n">quat</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">scalar_first</span><span class="o">=</span><span class="n">scalar_first</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Rotation.from_quat">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.from_quat">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_quat</span><span class="p">(</span><span class="n">quat</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">scalar_first</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize from quaternions.</span>

<span class="sd">        Rotations in 3 dimensions can be represented using unit norm</span>
<span class="sd">        quaternions [1]_.</span>

<span class="sd">        The 4 components of a quaternion are divided into a scalar part ``w``</span>
<span class="sd">        and a vector part ``(x, y, z)`` and can be expressed from the angle</span>
<span class="sd">        ``theta`` and the axis ``n`` of a rotation as follows::</span>

<span class="sd">            w = cos(theta / 2)</span>
<span class="sd">            x = sin(theta / 2) * n_x</span>
<span class="sd">            y = sin(theta / 2) * n_y</span>
<span class="sd">            z = sin(theta / 2) * n_z</span>

<span class="sd">        There are 2 conventions to order the components in a quaternion:</span>

<span class="sd">        - scalar-first order -- ``(w, x, y, z)``</span>
<span class="sd">        - scalar-last order -- ``(x, y, z, w)``</span>

<span class="sd">        The choice is controlled by `scalar_first` argument.</span>
<span class="sd">        By default, it is False and the scalar-last order is assumed.</span>

<span class="sd">        Advanced users may be interested in the &quot;double cover&quot; of 3D space by</span>
<span class="sd">        the quaternion representation [2]_. As of version 1.11.0, the</span>
<span class="sd">        following subset (and only this subset) of operations on a `Rotation`</span>
<span class="sd">        ``r`` corresponding to a quaternion ``q`` are guaranteed to preserve</span>
<span class="sd">        the double cover property: ``r = Rotation.from_quat(q)``,</span>
<span class="sd">        ``r.as_quat(canonical=False)``, ``r.inv()``, and composition using the</span>
<span class="sd">        ``*`` operator such as ``r*r``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        quat : array_like, shape (..., 4)</span>
<span class="sd">            Each row is a (possibly non-unit norm) quaternion representing an</span>
<span class="sd">            active rotation. Each quaternion will be normalized to unit norm.</span>
<span class="sd">        scalar_first : bool, optional</span>
<span class="sd">            Whether the scalar component goes first or last.</span>
<span class="sd">            Default is False, i.e. the scalar-last order is assumed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotation : `Rotation` instance</span>
<span class="sd">            Object containing the rotations represented by input quaternions.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation</span>
<span class="sd">        .. [2] Hanson, Andrew J. &quot;Visualizing quaternions.&quot;</span>
<span class="sd">            Morgan Kaufmann Publishers Inc., San Francisco, CA. 2006.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>

<span class="sd">        A rotation can be initialized from a quaternion with the scalar-last</span>
<span class="sd">        (default) or scalar-first component order as shown below:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_quat([0, 0, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix()</span>
<span class="sd">        array([[1., 0., 0.],</span>
<span class="sd">               [0., 1., 0.],</span>
<span class="sd">               [0., 0., 1.]])</span>
<span class="sd">        &gt;&gt;&gt; r = R.from_quat([1, 0, 0, 0], scalar_first=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix()</span>
<span class="sd">        array([[1., 0., 0.],</span>
<span class="sd">               [0., 1., 0.],</span>
<span class="sd">               [0., 0., 1.]])</span>

<span class="sd">        It is possible to initialize multiple rotations in a single object by</span>
<span class="sd">        passing an N-dimensional array:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_quat([[</span>
<span class="sd">        ... [1, 0, 0, 0],</span>
<span class="sd">        ... [0, 0, 0, 1]</span>
<span class="sd">        ... ]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat()</span>
<span class="sd">        array([[[1., 0., 0., 0.],</span>
<span class="sd">                [0., 0., 0., 1.]]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat().shape</span>
<span class="sd">        (1, 2, 4)</span>

<span class="sd">        It is also possible to have a stack of a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_quat([[0, 0, 0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat()</span>
<span class="sd">        array([[0., 0., 0., 1.]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat().shape</span>
<span class="sd">        (1, 4)</span>

<span class="sd">        Quaternions are normalized before initialization.</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_quat([0, 0, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat()</span>
<span class="sd">        array([0.        , 0.        , 0.70710678, 0.70710678])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scalar_first</span><span class="o">=</span><span class="n">scalar_first</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rotation.from_matrix">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.from_matrix">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">assume_valid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize from rotation matrix.</span>

<span class="sd">        Rotations in 3 dimensions can be represented with 3 x 3 orthogonal</span>
<span class="sd">        matrices [1]_. If the input is not orthogonal, an approximation is</span>
<span class="sd">        created by orthogonalizing the input matrix using the method described</span>
<span class="sd">        in [2]_, and then converting the orthogonal rotation matrices to</span>
<span class="sd">        quaternions using the algorithm described in [3]_. Matrices must be</span>
<span class="sd">        right-handed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : array_like, shape (..., 3, 3)</span>
<span class="sd">            A single matrix or an ND array of matrices, where the last two dimensions</span>
<span class="sd">            contain the rotation matrices.</span>
<span class="sd">        assume_valid : bool, optional</span>
<span class="sd">            Must be False unless users can guarantee the input is a valid rotation</span>
<span class="sd">            matrix, i.e. it is orthogonal, rows and columns have unit norm and the</span>
<span class="sd">            determinant is 1. Setting this to True without ensuring these properties</span>
<span class="sd">            is unsafe and will silently lead to incorrect results. If True,</span>
<span class="sd">            normalization steps are skipped, which can improve runtime performance.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotation : `Rotation` instance</span>
<span class="sd">            Object containing the rotations represented by the rotation</span>
<span class="sd">            matrices.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions</span>
<span class="sd">        .. [2] https://en.wikipedia.org/wiki/Orthogonal_Procrustes_problem</span>
<span class="sd">        .. [3] F. Landis Markley, &quot;Unit Quaternion from Rotation Matrix&quot;,</span>
<span class="sd">               Journal of guidance, control, and dynamics vol. 31.2, pp.</span>
<span class="sd">               440-442, 2008.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        Initialize a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_matrix([</span>
<span class="sd">        ... [0, -1, 0],</span>
<span class="sd">        ... [1, 0, 0],</span>
<span class="sd">        ... [0, 0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; r.single</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix().shape</span>
<span class="sd">        (3, 3)</span>

<span class="sd">        Initialize multiple rotations in a single object:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_matrix([</span>
<span class="sd">        ... [</span>
<span class="sd">        ...     [0, -1, 0],</span>
<span class="sd">        ...     [1, 0, 0],</span>
<span class="sd">        ...     [0, 0, 1],</span>
<span class="sd">        ... ],</span>
<span class="sd">        ... [</span>
<span class="sd">        ...     [1, 0, 0],</span>
<span class="sd">        ...     [0, 0, -1],</span>
<span class="sd">        ...     [0, 1, 0],</span>
<span class="sd">        ... ]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix().shape</span>
<span class="sd">        (2, 3, 3)</span>
<span class="sd">        &gt;&gt;&gt; r.single</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; len(r)</span>
<span class="sd">        2</span>

<span class="sd">        If input matrices are not special orthogonal (orthogonal with</span>
<span class="sd">        determinant equal to +1), then a special orthogonal estimate is stored:</span>

<span class="sd">        &gt;&gt;&gt; a = np.array([</span>
<span class="sd">        ... [0, -0.5, 0],</span>
<span class="sd">        ... [0.5, 0, 0],</span>
<span class="sd">        ... [0, 0, 0.5]])</span>
<span class="sd">        &gt;&gt;&gt; np.linalg.det(a)</span>
<span class="sd">        0.125</span>
<span class="sd">        &gt;&gt;&gt; r = R.from_matrix(a)</span>
<span class="sd">        &gt;&gt;&gt; matrix = r.as_matrix()</span>
<span class="sd">        &gt;&gt;&gt; matrix</span>
<span class="sd">        array([[ 0., -1.,  0.],</span>
<span class="sd">               [ 1.,  0.,  0.],</span>
<span class="sd">               [ 0.,  0.,  1.]])</span>
<span class="sd">        &gt;&gt;&gt; np.linalg.det(matrix)</span>
<span class="sd">        1.0</span>

<span class="sd">        It is also possible to have a stack containing a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_matrix([[</span>
<span class="sd">        ... [0, -1, 0],</span>
<span class="sd">        ... [1, 0, 0],</span>
<span class="sd">        ... [0, 0, 1]]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix()</span>
<span class="sd">        array([[[ 0., -1.,  0.],</span>
<span class="sd">                [ 1.,  0.,  0.],</span>
<span class="sd">                [ 0.,  0.,  1.]]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix().shape</span>
<span class="sd">        (1, 3, 3)</span>

<span class="sd">        We can also create an N-dimensional array of rotations:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_matrix(np.tile(np.eye(3), (2, 3, 1, 1)))</span>
<span class="sd">        &gt;&gt;&gt; r.shape</span>
<span class="sd">        (2, 3)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function was called from_dcm before.</span>

<span class="sd">        .. versionadded:: 1.4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">array_namespace</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">_promote</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span>
        <span class="c1"># Resulting quat will have 1 less dimension than matrix</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">select_backend</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">cython_compatible</span><span class="o">=</span><span class="n">matrix</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">quat</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">assume_valid</span><span class="o">=</span><span class="n">assume_valid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">_from_raw_quat</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rotation.from_rotvec">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.from_rotvec">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_rotvec</span><span class="p">(</span><span class="n">rotvec</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">degrees</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize from rotation vectors.</span>

<span class="sd">        A rotation vector is a 3 dimensional vector which is co-directional to</span>
<span class="sd">        the axis of rotation and whose norm gives the angle of rotation [1]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rotvec : array_like, shape (..., 3)</span>
<span class="sd">            A single vector or an ND array of vectors, where the last dimension</span>
<span class="sd">            contains the rotation vectors.</span>
<span class="sd">        degrees : bool, optional</span>
<span class="sd">            If True, then the given magnitudes are assumed to be in degrees.</span>
<span class="sd">            Default is False.</span>

<span class="sd">            .. versionadded:: 1.7.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotation : `Rotation` instance</span>
<span class="sd">            Object containing the rotations represented by input rotation</span>
<span class="sd">            vectors.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation#Rotation_vector</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        Initialize a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec(np.pi/2 * np.array([0, 0, 1]))</span>
<span class="sd">        &gt;&gt;&gt; r.as_rotvec()</span>
<span class="sd">        array([0.        , 0.        , 1.57079633])</span>
<span class="sd">        &gt;&gt;&gt; r.as_rotvec().shape</span>
<span class="sd">        (3,)</span>

<span class="sd">        Initialize a rotation in degrees, and view it in degrees:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec(45 * np.array([0, 1, 0]), degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_rotvec(degrees=True)</span>
<span class="sd">        array([ 0., 45.,  0.])</span>

<span class="sd">        Initialize multiple rotations in one object:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([</span>
<span class="sd">        ... [0, 0, np.pi/2],</span>
<span class="sd">        ... [np.pi/2, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_rotvec()</span>
<span class="sd">        array([[0.        , 0.        , 1.57079633],</span>
<span class="sd">               [1.57079633, 0.        , 0.        ]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_rotvec().shape</span>
<span class="sd">        (2, 3)</span>

<span class="sd">        It is also possible to have a stack of a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([[0, 0, np.pi/2]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_rotvec().shape</span>
<span class="sd">        (1, 3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">array_namespace</span><span class="p">(</span><span class="n">rotvec</span><span class="p">)</span>
        <span class="n">rotvec</span> <span class="o">=</span> <span class="n">_promote</span><span class="p">(</span><span class="n">rotvec</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">select_backend</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">cython_compatible</span><span class="o">=</span><span class="n">rotvec</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">quat</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotvec</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="n">degrees</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">_from_raw_quat</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rotation.from_euler">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.from_euler">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_euler</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">angles</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">degrees</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize from Euler angles.</span>

<span class="sd">        Rotations in 3-D can be represented by a sequence of 3</span>
<span class="sd">        rotations around a sequence of axes. In theory, any three axes spanning</span>
<span class="sd">        the 3-D Euclidean space are enough. In practice, the axes of rotation are</span>
<span class="sd">        chosen to be the basis vectors.</span>

<span class="sd">        The three rotations can either be in a global frame of reference</span>
<span class="sd">        (extrinsic) or in a body centred frame of reference (intrinsic), which</span>
<span class="sd">        is attached to, and moves with, the object under rotation [1]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seq : string</span>
<span class="sd">            Specifies sequence of axes for rotations. Up to 3 characters</span>
<span class="sd">            belonging to the set {&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;} for intrinsic rotations, or</span>
<span class="sd">            {&#39;x&#39;, &#39;y&#39;, &#39;z&#39;} for extrinsic rotations. Extrinsic and intrinsic</span>
<span class="sd">            rotations cannot be mixed in one function call.</span>
<span class="sd">        angles : float or array_like, shape (...,  [1 or 2 or 3])</span>
<span class="sd">            Euler angles specified in radians (`degrees` is False) or degrees</span>
<span class="sd">            (`degrees` is True).</span>
<span class="sd">            Each character in `seq` defines one axis around which `angles` turns.</span>
<span class="sd">            The resulting rotation has the shape np.atleast_1d(angles).shape[:-1].</span>
<span class="sd">            Dimensionless angles are thus only valid for single character `seq`.</span>

<span class="sd">        degrees : bool, optional</span>
<span class="sd">            If True, then the given angles are assumed to be in degrees.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotation : `Rotation` instance</span>
<span class="sd">            Object containing the rotation represented by the sequence of</span>
<span class="sd">            rotations around given axes with given angles.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Euler_angles#Definition_by_intrinsic_rotations</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>

<span class="sd">        Initialize a single rotation along a single axis:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_euler(&#39;x&#39;, 90, degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat().shape</span>
<span class="sd">        (4,)</span>

<span class="sd">        Initialize a single rotation with a given axis sequence:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_euler(&#39;zyx&#39;, [90, 45, 30], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat().shape</span>
<span class="sd">        (4,)</span>

<span class="sd">        Initialize a stack with a single rotation around a single axis:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_euler(&#39;x&#39;, [[90]], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat().shape</span>
<span class="sd">        (1, 4)</span>

<span class="sd">        Initialize a stack with a single rotation with an axis sequence:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_euler(&#39;zyx&#39;, [[90, 45, 30]], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat().shape</span>
<span class="sd">        (1, 4)</span>

<span class="sd">        Initialize multiple elementary rotations in one object:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_euler(&#39;x&#39;, [[90], [45], [30]], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat().shape</span>
<span class="sd">        (3, 4)</span>

<span class="sd">        Initialize multiple rotations in one object:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_euler(&#39;zyx&#39;, [[90, 45, 30], [35, 45, 90]], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat().shape</span>
<span class="sd">        (2, 4)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">array_namespace</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">_promote</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">select_backend</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">cython_compatible</span><span class="o">=</span><span class="n">angles</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">quat</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="n">degrees</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">_from_raw_quat</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rotation.from_davenport">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.from_davenport">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_davenport</span><span class="p">(</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">angles</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">degrees</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize from Davenport angles.</span>

<span class="sd">        Rotations in 3-D can be represented by a sequence of 3</span>
<span class="sd">        rotations around a sequence of axes.</span>

<span class="sd">        The three rotations can either be in a global frame of reference</span>
<span class="sd">        (extrinsic) or in a body centred frame of reference (intrinsic), which</span>
<span class="sd">        is attached to, and moves with, the object under rotation [1]_.</span>

<span class="sd">        For both Euler angles and Davenport angles, consecutive axes must</span>
<span class="sd">        be are orthogonal (``axis2`` is orthogonal to both ``axis1`` and</span>
<span class="sd">        ``axis3``). For Euler angles, there is an additional relationship</span>
<span class="sd">        between ``axis1`` or ``axis3``, with two possibilities:</span>

<span class="sd">            - ``axis1`` and ``axis3`` are also orthogonal (asymmetric sequence)</span>
<span class="sd">            - ``axis1 == axis3`` (symmetric sequence)</span>

<span class="sd">        For Davenport angles, this last relationship is relaxed [2]_, and only</span>
<span class="sd">        the consecutive orthogonal axes requirement is maintained.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : array_like, shape (3,) or (..., [1 or 2 or 3], 3)</span>
<span class="sd">            Axis of rotation, if one dimensional. If two or more dimensional, describes</span>
<span class="sd">            the sequence of axes for rotations, where each axes[..., i, :] is the ith</span>
<span class="sd">            axis. If more than one axis is given, then the second axis must be</span>
<span class="sd">            orthogonal to both the first and third axes.</span>
<span class="sd">        order : string</span>
<span class="sd">            If it is equal to &#39;e&#39; or &#39;extrinsic&#39;, the sequence will be</span>
<span class="sd">            extrinsic. If it is equal to &#39;i&#39; or &#39;intrinsic&#39;, sequence</span>
<span class="sd">            will be treated as intrinsic.</span>
<span class="sd">        angles : float or array_like, shape (..., [1 or 2 or 3])</span>
<span class="sd">            Angles specified in radians (`degrees` is False) or degrees</span>
<span class="sd">            (`degrees` is True).</span>
<span class="sd">            Each angle i in the last dimension of `angles` turns around the corresponding</span>
<span class="sd">            axis axis[..., i, :]. The resulting rotation has the shape</span>
<span class="sd">            np.broadcast_shapes(np.atleast_2d(axes).shape[:-2], np.atleast_1d(angles).shape[:-1])</span>
<span class="sd">            Dimensionless angles are thus only valid for a single axis.</span>

<span class="sd">        degrees : bool, optional</span>
<span class="sd">            If True, then the given angles are assumed to be in degrees.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotation : `Rotation` instance</span>
<span class="sd">            Object containing the rotation represented by the sequence of</span>
<span class="sd">            rotations around given axes with given angles.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Euler_angles#Definition_by_intrinsic_rotations</span>
<span class="sd">        .. [2] Shuster, Malcolm &amp; Markley, Landis. (2003). Generalization of</span>
<span class="sd">               the Euler Angles. Journal of the Astronautical Sciences. 51. 123-132.</span>
<span class="sd">               10.1007/BF03546304.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>

<span class="sd">        Davenport angles are a generalization of Euler angles, when we use the</span>
<span class="sd">        canonical basis axes:</span>

<span class="sd">        &gt;&gt;&gt; ex = [1, 0, 0]</span>
<span class="sd">        &gt;&gt;&gt; ey = [0, 1, 0]</span>
<span class="sd">        &gt;&gt;&gt; ez = [0, 0, 1]</span>

<span class="sd">        Initialize a single rotation with a given axis sequence:</span>

<span class="sd">        &gt;&gt;&gt; axes = [ez, ey, ex]</span>
<span class="sd">        &gt;&gt;&gt; r = R.from_davenport(axes, &#39;extrinsic&#39;, [90, 0, 0], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat().shape</span>
<span class="sd">        (4,)</span>

<span class="sd">        It is equivalent to Euler angles in this case:</span>

<span class="sd">        &gt;&gt;&gt; r.as_euler(&#39;zyx&#39;, degrees=True)</span>
<span class="sd">        array([90.,  0., -0.])</span>

<span class="sd">        Initialize multiple rotations in one object:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_davenport(axes, &#39;extrinsic&#39;, [[90, 45, 30], [35, 45, 90]], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat().shape</span>
<span class="sd">        (2, 4)</span>

<span class="sd">        Using only one or two axes is also possible:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_davenport([ez, ex], &#39;extrinsic&#39;, [[90, 45], [35, 45]], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat().shape</span>
<span class="sd">        (2, 4)</span>

<span class="sd">        Non-canonical axes are possible, and they do not need to be normalized,</span>
<span class="sd">        as long as consecutive axes are orthogonal:</span>

<span class="sd">        &gt;&gt;&gt; e1 = [2, 0, 0]</span>
<span class="sd">        &gt;&gt;&gt; e2 = [0, 1, 0]</span>
<span class="sd">        &gt;&gt;&gt; e3 = [1, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; axes = [e1, e2, e3]</span>
<span class="sd">        &gt;&gt;&gt; r = R.from_davenport(axes, &#39;extrinsic&#39;, [90, 45, 30], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat()</span>
<span class="sd">        [ 0.701057,  0.430459, -0.092296,  0.560986]</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">array_namespace</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">,</span> <span class="n">angles</span> <span class="o">=</span> <span class="n">_promote</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span>
        <span class="n">cython_compatible</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">angles</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">select_backend</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">cython_compatible</span><span class="o">=</span><span class="n">cython_compatible</span><span class="p">)</span>
        <span class="n">quat</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">from_davenport</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">degrees</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">_from_raw_quat</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rotation.from_mrp">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.from_mrp">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_mrp</span><span class="p">(</span><span class="n">mrp</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize from Modified Rodrigues Parameters (MRPs).</span>

<span class="sd">        MRPs are a 3 dimensional vector co-directional to the axis of rotation and whose</span>
<span class="sd">        magnitude is equal to ``tan(theta / 4)``, where ``theta`` is the angle of</span>
<span class="sd">        rotation (in radians) [1]_.</span>

<span class="sd">        MRPs have a singularity at 360 degrees which can be avoided by ensuring the</span>
<span class="sd">        angle of rotation does not exceed 180 degrees, i.e. switching the direction of</span>
<span class="sd">        the rotation when it is past 180 degrees.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mrp : array_like, shape (..., 3)</span>
<span class="sd">            A single vector or an ND array of vectors, where the last dimension</span>
<span class="sd">            contains the rotation parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotation : `Rotation` instance</span>
<span class="sd">            Object containing the rotations represented by input MRPs.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Shuster, M. D. &quot;A Survey of Attitude Representations&quot;,</span>
<span class="sd">               The Journal of Astronautical Sciences, Vol. 41, No.4, 1993,</span>
<span class="sd">               pp. 475-476</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        .. versionadded:: 1.6.0</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        Initialize a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_mrp([0, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; r.as_euler(&#39;xyz&#39;, degrees=True)</span>
<span class="sd">        array([0.        , 0.        , 180.      ])</span>
<span class="sd">        &gt;&gt;&gt; r.as_euler(&#39;xyz&#39;).shape</span>
<span class="sd">        (3,)</span>

<span class="sd">        Initialize multiple rotations in one object:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_mrp([</span>
<span class="sd">        ... [0, 0, 1],</span>
<span class="sd">        ... [1, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_euler(&#39;xyz&#39;, degrees=True)</span>
<span class="sd">        array([[0.        , 0.        , 180.      ],</span>
<span class="sd">               [180.0     , 0.        , 0.        ]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_euler(&#39;xyz&#39;).shape</span>
<span class="sd">        (2, 3)</span>

<span class="sd">        It is also possible to have a stack of a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_mrp([[0, 0, np.pi/2]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_euler(&#39;xyz&#39;).shape</span>
<span class="sd">        (1, 3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">array_namespace</span><span class="p">(</span><span class="n">mrp</span><span class="p">)</span>
        <span class="n">mrp</span> <span class="o">=</span> <span class="n">_promote</span><span class="p">(</span><span class="n">mrp</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">select_backend</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">cython_compatible</span><span class="o">=</span><span class="n">mrp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">quat</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">from_mrp</span><span class="p">(</span><span class="n">mrp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">_from_raw_quat</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rotation.as_quat">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.as_quat">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_quat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">canonical</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">scalar_first</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Represent as quaternions.</span>

<span class="sd">        Rotations in 3 dimensions can be represented using unit norm</span>
<span class="sd">        quaternions [1]_.</span>

<span class="sd">        The 4 components of a quaternion are divided into a scalar part ``w``</span>
<span class="sd">        and a vector part ``(x, y, z)`` and can be expressed from the angle</span>
<span class="sd">        ``theta`` and the axis ``n`` of a rotation as follows::</span>

<span class="sd">            w = cos(theta / 2)</span>
<span class="sd">            x = sin(theta / 2) * n_x</span>
<span class="sd">            y = sin(theta / 2) * n_y</span>
<span class="sd">            z = sin(theta / 2) * n_z</span>

<span class="sd">        There are 2 conventions to order the components in a quaternion:</span>

<span class="sd">        - scalar-first order -- ``(w, x, y, z)``</span>
<span class="sd">        - scalar-last order -- ``(x, y, z, w)``</span>

<span class="sd">        The choice is controlled by `scalar_first` argument.</span>
<span class="sd">        By default, it is False and the scalar-last order is used.</span>

<span class="sd">        The mapping from quaternions to rotations is</span>
<span class="sd">        two-to-one, i.e. quaternions ``q`` and ``-q``, where ``-q`` simply</span>
<span class="sd">        reverses the sign of each component, represent the same spatial</span>
<span class="sd">        rotation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        canonical : `bool`, default False</span>
<span class="sd">            Whether to map the redundant double cover of rotation space to a</span>
<span class="sd">            unique &quot;canonical&quot; single cover. If True, then the quaternion is</span>
<span class="sd">            chosen from {q, -q} such that the w term is positive. If the w term</span>
<span class="sd">            is 0, then the quaternion is chosen such that the first nonzero</span>
<span class="sd">            term of the x, y, and z terms is positive.</span>
<span class="sd">        scalar_first : bool, optional</span>
<span class="sd">            Whether the scalar component goes first or last.</span>
<span class="sd">            Default is False, i.e. the scalar-last order is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        quat : `numpy.ndarray`, shape (..., 4)</span>
<span class="sd">            Shape depends on shape of inputs used for initialization.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        A rotation can be represented as a quaternion with either scalar-last</span>
<span class="sd">        (default) or scalar-first component order.</span>
<span class="sd">        This is shown for a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_matrix(np.eye(3))</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat()</span>
<span class="sd">        array([0., 0., 0., 1.])</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat(scalar_first=True)</span>
<span class="sd">        array([1., 0., 0., 0.])</span>

<span class="sd">        The resulting shape of the quaternion is always the shape of the Rotation</span>
<span class="sd">        object with an added last dimension of size 4. E.g. when the `Rotation` object</span>
<span class="sd">        contains an N-dimensional array (N, M, K) of rotations, the result will be a</span>
<span class="sd">        4-dimensional array:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec(np.ones((2, 3, 4, 3)))</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat().shape</span>
<span class="sd">        (2, 3, 4, 4)</span>

<span class="sd">        Quaternions can be mapped from a redundant double cover of the</span>
<span class="sd">        rotation space to a canonical representation with a positive w term.</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_quat([0, 0, 0, -1])</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat()</span>
<span class="sd">        array([0. , 0. , 0. , -1.])</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat(canonical=True)</span>
<span class="sd">        array([0. , 0. , 0. , 1.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">quat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">as_quat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">,</span> <span class="n">canonical</span><span class="o">=</span><span class="n">canonical</span><span class="p">,</span> <span class="n">scalar_first</span><span class="o">=</span><span class="n">scalar_first</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">quat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">quat</span></div>


<div class="viewcode-block" id="Rotation.as_matrix">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.as_matrix">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Represent as rotation matrix.</span>

<span class="sd">        3D rotations can be represented using rotation matrices, which</span>
<span class="sd">        are 3 x 3 real orthogonal matrices with determinant equal to +1 [1]_.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matrix : ndarray, shape (..., 3)</span>
<span class="sd">            Shape depends on shape of inputs used for initialization.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        Represent a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([0, 0, np.pi/2])</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix()</span>
<span class="sd">        array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="sd">               [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="sd">               [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix().shape</span>
<span class="sd">        (3, 3)</span>

<span class="sd">        Represent a stack with a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_quat([[1, 1, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix()</span>
<span class="sd">        array([[[ 0.,  1.,  0.],</span>
<span class="sd">                [ 1.,  0.,  0.],</span>
<span class="sd">                [ 0.,  0., -1.]]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix().shape</span>
<span class="sd">        (1, 3, 3)</span>

<span class="sd">        Represent multiple rotations:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([[np.pi/2, 0, 0], [0, 0, np.pi/2]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix()</span>
<span class="sd">        array([[[ 1.00000000e+00,  0.00000000e+00,  0.00000000e+00],</span>
<span class="sd">                [ 0.00000000e+00,  2.22044605e-16, -1.00000000e+00],</span>
<span class="sd">                [ 0.00000000e+00,  1.00000000e+00,  2.22044605e-16]],</span>
<span class="sd">               [[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="sd">                [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="sd">                [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix().shape</span>
<span class="sd">        (2, 3, 3)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function was called as_dcm before.</span>

<span class="sd">        .. versionadded:: 1.4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">matrix</span></div>


<div class="viewcode-block" id="Rotation.as_rotvec">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.as_rotvec">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_rotvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Represent as rotation vectors.</span>

<span class="sd">        A rotation vector is a 3 dimensional vector which is co-directional to</span>
<span class="sd">        the axis of rotation and whose norm gives the angle of rotation [1]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        degrees : boolean, optional</span>
<span class="sd">            Returned magnitudes are in degrees if this flag is True, else they are</span>
<span class="sd">            in radians. Default is False.</span>

<span class="sd">            .. versionadded:: 1.7.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotvec : ndarray, shape (..., 3)</span>
<span class="sd">            Shape depends on shape of inputs used for initialization.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation#Rotation_vector</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        Represent a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_euler(&#39;z&#39;, 90, degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_rotvec()</span>
<span class="sd">        array([0.        , 0.        , 1.57079633])</span>
<span class="sd">        &gt;&gt;&gt; r.as_rotvec().shape</span>
<span class="sd">        (3,)</span>

<span class="sd">        Represent a rotation in degrees:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_euler(&#39;YX&#39;, (-90, -90), degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; s = r.as_rotvec(degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        array([-69.2820323, -69.2820323, -69.2820323])</span>
<span class="sd">        &gt;&gt;&gt; np.linalg.norm(s)</span>
<span class="sd">        120.00000000000001</span>

<span class="sd">        Represent a stack with a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_quat([[0, 0, 1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_rotvec()</span>
<span class="sd">        array([[0.        , 0.        , 1.57079633]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_rotvec().shape</span>
<span class="sd">        (1, 3)</span>

<span class="sd">        Represent multiple rotations in a single object:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_quat([[0, 0, 1, 1], [1, 1, 0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_rotvec()</span>
<span class="sd">        array([[0.        , 0.        , 1.57079633],</span>
<span class="sd">               [1.35102172, 1.35102172, 0.        ]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_rotvec().shape</span>
<span class="sd">        (2, 3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rotvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="n">degrees</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rotvec</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">rotvec</span></div>


<div class="viewcode-block" id="Rotation.as_euler">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.as_euler">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_euler</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">degrees</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Represent as Euler angles.</span>

<span class="sd">        Any orientation can be expressed as a composition of 3 elementary</span>
<span class="sd">        rotations. Once the axis sequence has been chosen, Euler angles define</span>
<span class="sd">        the angle of rotation around each respective axis [1]_.</span>

<span class="sd">        The algorithm from [2]_ has been used to calculate Euler angles for the</span>
<span class="sd">        rotation about a given sequence of axes.</span>

<span class="sd">        Euler angles suffer from the problem of gimbal lock [3]_, where the</span>
<span class="sd">        representation loses a degree of freedom and it is not possible to</span>
<span class="sd">        determine the first and third angles uniquely. In this case,</span>
<span class="sd">        a warning is raised (unless the ``suppress_warnings`` option is used),</span>
<span class="sd">        and the third angle is set to zero. Note however that the returned</span>
<span class="sd">        angles still represent the correct rotation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seq : string, length 3</span>
<span class="sd">            3 characters belonging to the set {&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;} for intrinsic</span>
<span class="sd">            rotations, or {&#39;x&#39;, &#39;y&#39;, &#39;z&#39;} for extrinsic rotations [1]_.</span>
<span class="sd">            Adjacent axes cannot be the same.</span>
<span class="sd">            Extrinsic and intrinsic rotations cannot be mixed in one function</span>
<span class="sd">            call.</span>
<span class="sd">        degrees : boolean, optional</span>
<span class="sd">            Returned angles are in degrees if this flag is True, else they are</span>
<span class="sd">            in radians. Default is False.</span>
<span class="sd">        suppress_warnings : boolean, optional</span>
<span class="sd">            Disable warnings about gimbal lock. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        angles : ndarray, shape (..., 3)</span>
<span class="sd">            Shape depends on shape of inputs used to initialize object.</span>
<span class="sd">            The returned angles are in the range:</span>

<span class="sd">            - First angle belongs to [-180, 180] degrees (both inclusive)</span>
<span class="sd">            - Third angle belongs to [-180, 180] degrees (both inclusive)</span>
<span class="sd">            - Second angle belongs to:</span>

<span class="sd">                - [-90, 90] degrees if all axes are different (like xyz)</span>
<span class="sd">                - [0, 180] degrees if first and third axes are the same</span>
<span class="sd">                  (like zxz)</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Euler_angles#Definition_by_intrinsic_rotations</span>
<span class="sd">        .. [2] Bernardes E, Viollet S (2022) Quaternion to Euler angles</span>
<span class="sd">               conversion: A direct, general and computationally efficient</span>
<span class="sd">               method. PLoS ONE 17(11): e0276302.</span>
<span class="sd">               https://doi.org/10.1371/journal.pone.0276302</span>
<span class="sd">        .. [3] https://en.wikipedia.org/wiki/Gimbal_lock#In_applied_mathematics</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        Represent a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([0, 0, np.pi/2])</span>
<span class="sd">        &gt;&gt;&gt; r.as_euler(&#39;zxy&#39;, degrees=True)</span>
<span class="sd">        array([90.,  0.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; r.as_euler(&#39;zxy&#39;, degrees=True).shape</span>
<span class="sd">        (3,)</span>

<span class="sd">        Represent a stack of single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([[0, 0, np.pi/2]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_euler(&#39;zxy&#39;, degrees=True)</span>
<span class="sd">        array([[90.,  0.,  0.]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_euler(&#39;zxy&#39;, degrees=True).shape</span>
<span class="sd">        (1, 3)</span>

<span class="sd">        Represent multiple rotations in a single object:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([</span>
<span class="sd">        ... [0, 0, np.pi/2],</span>
<span class="sd">        ... [0, -np.pi/3, 0],</span>
<span class="sd">        ... [np.pi/4, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_euler(&#39;zxy&#39;, degrees=True)</span>
<span class="sd">        array([[ 90.,   0.,   0.],</span>
<span class="sd">               [  0.,   0., -60.],</span>
<span class="sd">               [  0.,  45.,   0.]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_euler(&#39;zxy&#39;, degrees=True).shape</span>
<span class="sd">        (3, 3)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">euler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">as_euler</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="n">degrees</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="n">suppress_warnings</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">euler</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">euler</span></div>


<div class="viewcode-block" id="Rotation.as_davenport">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.as_davenport">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions and .mT attribute&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;cupy&quot;</span><span class="p">,</span> <span class="s2">&quot;missing .mT attribute in cupy&lt;14.*&quot;</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_davenport</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">degrees</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">suppress_warnings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Represent as Davenport angles.</span>

<span class="sd">        Any orientation can be expressed as a composition of 3 elementary</span>
<span class="sd">        rotations.</span>

<span class="sd">        For both Euler angles and Davenport angles, consecutive axes must</span>
<span class="sd">        be are orthogonal (``axis2`` is orthogonal to both ``axis1`` and</span>
<span class="sd">        ``axis3``). For Euler angles, there is an additional relationship</span>
<span class="sd">        between ``axis1`` or ``axis3``, with two possibilities:</span>

<span class="sd">            - ``axis1`` and ``axis3`` are also orthogonal (asymmetric sequence)</span>
<span class="sd">            - ``axis1 == axis3`` (symmetric sequence)</span>

<span class="sd">        For Davenport angles, this last relationship is relaxed [1]_, and only</span>
<span class="sd">        the consecutive orthogonal axes requirement is maintained.</span>

<span class="sd">        A slightly modified version of the algorithm from [2]_ has been used to</span>
<span class="sd">        calculate Davenport angles for the rotation about a given sequence of</span>
<span class="sd">        axes.</span>

<span class="sd">        Davenport angles, just like Euler angles, suffer from the problem of</span>
<span class="sd">        gimbal lock [3]_, where the representation loses a degree of freedom</span>
<span class="sd">        and it is not possible to determine the first and third angles</span>
<span class="sd">        uniquely. In this case, a warning is raised (unless the</span>
<span class="sd">        ``suppress_warnings`` option is used), and the third angle is set</span>
<span class="sd">        to zero. Note however that the returned angles still represent the</span>
<span class="sd">        correct rotation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : array_like, shape (..., [1 or 2 or 3], 3) or (..., 3)</span>
<span class="sd">            Axis of rotation, if one dimensional. If N dimensional, describes the</span>
<span class="sd">            sequence of axes for rotations, where each axes[..., i, :] is the ith</span>
<span class="sd">            axis. If more than one axis is given, then the second axis must be</span>
<span class="sd">            orthogonal to both the first and third axes.</span>
<span class="sd">        order : string</span>
<span class="sd">            If it belongs to the set {&#39;e&#39;, &#39;extrinsic&#39;}, the sequence will be</span>
<span class="sd">            extrinsic. If it belongs to the set {&#39;i&#39;, &#39;intrinsic&#39;}, sequence</span>
<span class="sd">            will be treated as intrinsic.</span>
<span class="sd">        degrees : boolean, optional</span>
<span class="sd">            Returned angles are in degrees if this flag is True, else they are</span>
<span class="sd">            in radians. Default is False.</span>
<span class="sd">        suppress_warnings : boolean, optional</span>
<span class="sd">            Disable warnings about gimbal lock. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        angles : ndarray, shape (..., 3)</span>
<span class="sd">            Shape depends on shape of inputs used to initialize object.</span>
<span class="sd">            The returned angles are in the range:</span>

<span class="sd">            - First angle belongs to [-180, 180] degrees (both inclusive)</span>
<span class="sd">            - Third angle belongs to [-180, 180] degrees (both inclusive)</span>
<span class="sd">            - Second angle belongs to a set of size 180 degrees,</span>
<span class="sd">              given by: ``[-abs(lambda), 180 - abs(lambda)]``, where ``lambda``</span>
<span class="sd">              is the angle between the first and third axes.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Shuster, Malcolm &amp; Markley, Landis. (2003). Generalization of</span>
<span class="sd">               the Euler Angles. Journal of the Astronautical Sciences. 51. 123-132.</span>
<span class="sd">               10.1007/BF03546304.</span>
<span class="sd">        .. [2] Bernardes E, Viollet S (2022) Quaternion to Euler angles</span>
<span class="sd">               conversion: A direct, general and computationally efficient method.</span>
<span class="sd">               PLoS ONE 17(11): e0276302. 10.1371/journal.pone.0276302</span>
<span class="sd">        .. [3] https://en.wikipedia.org/wiki/Gimbal_lock#In_applied_mathematics</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        Davenport angles are a generalization of Euler angles, when we use the</span>
<span class="sd">        canonical basis axes:</span>

<span class="sd">        &gt;&gt;&gt; ex = [1, 0, 0]</span>
<span class="sd">        &gt;&gt;&gt; ey = [0, 1, 0]</span>
<span class="sd">        &gt;&gt;&gt; ez = [0, 0, 1]</span>

<span class="sd">        Represent a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([0, 0, np.pi/2])</span>
<span class="sd">        &gt;&gt;&gt; r.as_davenport([ez, ex, ey], &#39;extrinsic&#39;, degrees=True)</span>
<span class="sd">        array([90.,  0.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; r.as_euler(&#39;zxy&#39;, degrees=True)</span>
<span class="sd">        array([90.,  0.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; r.as_davenport([ez, ex, ey], &#39;extrinsic&#39;, degrees=True).shape</span>
<span class="sd">        (3,)</span>

<span class="sd">        Represent a stack of single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([[0, 0, np.pi/2]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_davenport([ez, ex, ey], &#39;extrinsic&#39;, degrees=True)</span>
<span class="sd">        array([[90.,  0.,  0.]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_davenport([ez, ex, ey], &#39;extrinsic&#39;, degrees=True).shape</span>
<span class="sd">        (1, 3)</span>

<span class="sd">        Represent multiple rotations in a single object:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([</span>
<span class="sd">        ... [0, 0, 90],</span>
<span class="sd">        ... [45, 0, 0]], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_davenport([ez, ex, ey], &#39;extrinsic&#39;, degrees=True)</span>
<span class="sd">        array([[90.,  0.,  0.],</span>
<span class="sd">               [ 0., 45.,  0.]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_davenport([ez, ex, ey], &#39;extrinsic&#39;, degrees=True).shape</span>
<span class="sd">        (2, 3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">axes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">xp_device</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">davenport</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">as_davenport</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="n">suppress_warnings</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">davenport</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">davenport</span></div>


<div class="viewcode-block" id="Rotation.as_mrp">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.as_mrp">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_mrp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Represent as Modified Rodrigues Parameters (MRPs).</span>

<span class="sd">        MRPs are a 3 dimensional vector co-directional to the axis of rotation and whose</span>
<span class="sd">        magnitude is equal to ``tan(theta / 4)``, where ``theta`` is the angle of</span>
<span class="sd">        rotation (in radians) [1]_.</span>

<span class="sd">        MRPs have a singularity at 360 degrees which can be avoided by ensuring the</span>
<span class="sd">        angle of rotation does not exceed 180 degrees, i.e. switching the direction of</span>
<span class="sd">        the rotation when it is past 180 degrees. This function will always return MRPs</span>
<span class="sd">        corresponding to a rotation of less than or equal to 180 degrees.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mrps : ndarray, shape (..., 3)</span>
<span class="sd">            Shape depends on shape of inputs used for initialization.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Shuster, M. D. &quot;A Survey of Attitude Representations&quot;,</span>
<span class="sd">               The Journal of Astronautical Sciences, Vol. 41, No.4, 1993,</span>
<span class="sd">               pp. 475-476</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        Represent a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([0, 0, np.pi])</span>
<span class="sd">        &gt;&gt;&gt; r.as_mrp()</span>
<span class="sd">        array([0.        , 0.        , 1.         ])</span>
<span class="sd">        &gt;&gt;&gt; r.as_mrp().shape</span>
<span class="sd">        (3,)</span>

<span class="sd">        Represent a stack with a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_euler(&#39;xyz&#39;, [[180, 0, 0]], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.as_mrp()</span>
<span class="sd">        array([[1.       , 0.        , 0.         ]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_mrp().shape</span>
<span class="sd">        (1, 3)</span>

<span class="sd">        Represent multiple rotations:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([[np.pi/2, 0, 0], [0, 0, np.pi/2]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_mrp()</span>
<span class="sd">        array([[0.41421356, 0.        , 0.        ],</span>
<span class="sd">               [0.        , 0.        , 0.41421356]])</span>
<span class="sd">        &gt;&gt;&gt; r.as_mrp().shape</span>
<span class="sd">        (2, 3)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        .. versionadded:: 1.6.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mrp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">as_mrp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mrp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">mrp</span></div>


<div class="viewcode-block" id="Rotation.concatenate">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.concatenate">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">concatenate</span><span class="p">(</span><span class="n">rotations</span><span class="p">:</span> <span class="n">Rotation</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Rotation</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Concatenate a sequence of `Rotation` objects into a single object.</span>

<span class="sd">        This is useful if you want to, for example, take the mean of a set of</span>
<span class="sd">        rotations and need to pack them into a single object to do so.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rotations : sequence of `Rotation` objects</span>
<span class="sd">            The rotations to concatenate. If a single `Rotation` object is</span>
<span class="sd">            passed in, a copy is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        concatenated : `Rotation` instance</span>
<span class="sd">            The concatenated rotations.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; r1 = R.from_rotvec([0, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; r2 = R.from_rotvec([0, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; rc = R.concatenate([r1, r2])</span>
<span class="sd">        &gt;&gt;&gt; rc.as_rotvec()</span>
<span class="sd">        array([[0., 0., 1.],</span>
<span class="sd">               [0., 0., 2.]])</span>
<span class="sd">        &gt;&gt;&gt; rc.mean().as_rotvec()</span>
<span class="sd">        array([0., 0., 1.5])</span>

<span class="sd">        Concatenation of a split rotation recovers the original object.</span>

<span class="sd">        &gt;&gt;&gt; rs = [r for r in rc]</span>
<span class="sd">        &gt;&gt;&gt; R.concatenate(rs).as_rotvec()</span>
<span class="sd">        array([[0., 0., 1.],</span>
<span class="sd">               [0., 0., 2.]])</span>

<span class="sd">        Note that it may be simpler to create the desired rotations by passing</span>
<span class="sd">        in a single list of the data during initialization, rather then by</span>
<span class="sd">        concatenating:</span>

<span class="sd">        &gt;&gt;&gt; R.from_rotvec([[0, 0, 1], [0, 0, 2]]).as_rotvec()</span>
<span class="sd">        array([[0., 0., 1.],</span>
<span class="sd">               [0., 0., 2.]])</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. versionadded:: 1.8.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rotations</span><span class="p">,</span> <span class="n">Rotation</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Rotation</span><span class="p">(</span><span class="n">rotations</span><span class="o">.</span><span class="n">as_quat</span><span class="p">(),</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Rotation</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rotations</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input must contain Rotation objects only&quot;</span><span class="p">)</span>

        <span class="n">xp</span> <span class="o">=</span> <span class="n">array_namespace</span><span class="p">(</span><span class="n">rotations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_quat</span><span class="p">())</span>
        <span class="n">quats</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span><span class="n">xpx</span><span class="o">.</span><span class="n">atleast_nd</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">as_quat</span><span class="p">(),</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rotations</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">_from_raw_quat</span><span class="p">(</span><span class="n">quats</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rotation.apply">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.apply">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions and .mT attribute&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;cupy&quot;</span><span class="p">,</span> <span class="s2">&quot;missing .mT attribute in cupy&lt;14.*&quot;</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vectors</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">inverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply this rotation to a set of vectors.</span>

<span class="sd">        If the original frame rotates to the final frame by this rotation, then</span>
<span class="sd">        its application to a vector can be seen in two ways:</span>

<span class="sd">            - As a projection of vector components expressed in the final frame</span>
<span class="sd">              to the original frame.</span>
<span class="sd">            - As the physical rotation of a vector being glued to the original</span>
<span class="sd">              frame as it rotates. In this case the vector components are</span>
<span class="sd">              expressed in the original frame before and after the rotation.</span>

<span class="sd">        In terms of rotation matrices, this application is the same as</span>
<span class="sd">        ``self.as_matrix() @ vectors``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vectors : array_like, shape (..., 3)</span>
<span class="sd">            Each `vectors[..., :]` represents a vector in 3D space. The shape of</span>
<span class="sd">            rotations and shape of vectors given must follow standard numpy</span>
<span class="sd">            broadcasting rules: either one of them equals unity or they both</span>
<span class="sd">            equal each other.</span>
<span class="sd">        inverse : boolean, optional</span>
<span class="sd">            If True then the inverse of the rotation(s) is applied to the input</span>
<span class="sd">            vectors. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotated_vectors : ndarray, shape (..., 3)</span>
<span class="sd">            Result of applying rotation on input vectors.</span>
<span class="sd">            Shape is determined according to numpy broadcasting rules. I.e., the result</span>
<span class="sd">            will have the shape `np.broadcast_shapes(r.shape, v.shape[:-1]) + (3,)`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        Single rotation applied on a single vector:</span>

<span class="sd">        &gt;&gt;&gt; vector = np.array([1, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([0, 0, np.pi/2])</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix()</span>
<span class="sd">        array([[ 2.22044605e-16, -1.00000000e+00,  0.00000000e+00],</span>
<span class="sd">               [ 1.00000000e+00,  2.22044605e-16,  0.00000000e+00],</span>
<span class="sd">               [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]])</span>
<span class="sd">        &gt;&gt;&gt; r.apply(vector)</span>
<span class="sd">        array([2.22044605e-16, 1.00000000e+00, 0.00000000e+00])</span>
<span class="sd">        &gt;&gt;&gt; r.apply(vector).shape</span>
<span class="sd">        (3,)</span>

<span class="sd">        Single rotation applied on multiple vectors:</span>

<span class="sd">        &gt;&gt;&gt; vectors = np.array([</span>
<span class="sd">        ... [1, 0, 0],</span>
<span class="sd">        ... [1, 2, 3]])</span>
<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([0, 0, np.pi/4])</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix()</span>
<span class="sd">        array([[ 0.70710678, -0.70710678,  0.        ],</span>
<span class="sd">               [ 0.70710678,  0.70710678,  0.        ],</span>
<span class="sd">               [ 0.        ,  0.        ,  1.        ]])</span>
<span class="sd">        &gt;&gt;&gt; r.apply(vectors)</span>
<span class="sd">        array([[ 0.70710678,  0.70710678,  0.        ],</span>
<span class="sd">               [-0.70710678,  2.12132034,  3.        ]])</span>
<span class="sd">        &gt;&gt;&gt; r.apply(vectors).shape</span>
<span class="sd">        (2, 3)</span>

<span class="sd">        Multiple rotations on a single vector:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec([[0, 0, np.pi/4], [np.pi/2, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; vector = np.array([1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix()</span>
<span class="sd">        array([[[ 7.07106781e-01, -7.07106781e-01,  0.00000000e+00],</span>
<span class="sd">                [ 7.07106781e-01,  7.07106781e-01,  0.00000000e+00],</span>
<span class="sd">                [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]],</span>
<span class="sd">               [[ 1.00000000e+00,  0.00000000e+00,  0.00000000e+00],</span>
<span class="sd">                [ 0.00000000e+00,  2.22044605e-16, -1.00000000e+00],</span>
<span class="sd">                [ 0.00000000e+00,  1.00000000e+00,  2.22044605e-16]]])</span>
<span class="sd">        &gt;&gt;&gt; r.apply(vector)</span>
<span class="sd">        array([[-0.70710678,  2.12132034,  3.        ],</span>
<span class="sd">               [ 1.        , -3.        ,  2.        ]])</span>
<span class="sd">        &gt;&gt;&gt; r.apply(vector).shape</span>
<span class="sd">        (2, 3)</span>

<span class="sd">        Multiple rotations on multiple vectors. Each rotation is applied on the</span>
<span class="sd">        corresponding vector:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_euler(&#39;zxy&#39;, [</span>
<span class="sd">        ... [0, 0, 90],</span>
<span class="sd">        ... [45, 30, 60]], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; vectors = [</span>
<span class="sd">        ... [1, 2, 3],</span>
<span class="sd">        ... [1, 0, -1]]</span>
<span class="sd">        &gt;&gt;&gt; r.apply(vectors)</span>
<span class="sd">        array([[ 3.        ,  2.        , -1.        ],</span>
<span class="sd">               [-0.09026039,  1.11237244, -0.86860844]])</span>
<span class="sd">        &gt;&gt;&gt; r.apply(vectors).shape</span>
<span class="sd">        (2, 3)</span>

<span class="sd">        Broadcasting rules apply:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_rotvec(np.tile([0, 0, np.pi/4], (5, 1, 4, 1)))</span>
<span class="sd">        &gt;&gt;&gt; vectors = np.ones((3, 4, 3))</span>
<span class="sd">        &gt;&gt;&gt; r.shape, vectors.shape</span>
<span class="sd">        ((5, 1, 4), (3, 4, 3))</span>
<span class="sd">        &gt;&gt;&gt; r.apply(vectors).shape</span>
<span class="sd">        (5, 3, 4, 3)</span>

<span class="sd">        It is also possible to apply the inverse rotation:</span>

<span class="sd">        &gt;&gt;&gt; r = R.from_euler(&#39;zxy&#39;, [</span>
<span class="sd">        ... [0, 0, 90],</span>
<span class="sd">        ... [45, 30, 60]], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; vectors = [</span>
<span class="sd">        ... [1, 2, 3],</span>
<span class="sd">        ... [1, 0, -1]]</span>
<span class="sd">        &gt;&gt;&gt; r.apply(vectors, inverse=True)</span>
<span class="sd">        array([[-3.        ,  2.        ,  1.        ],</span>
<span class="sd">               [ 1.09533535, -0.8365163 ,  0.3169873 ]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">vectors</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">xp_device</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">single_vector</span> <span class="o">=</span> <span class="n">vectors</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="c1"># Numpy optimization: The Cython backend typing requires us to have fixed</span>
        <span class="c1"># dimensions, so for the Numpy case we always broadcast the vector to 2D.</span>
        <span class="k">if</span> <span class="n">vectors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected input of shape (..., 3), got </span><span class="si">{</span><span class="n">vectors</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xp</span><span class="p">):</span>
            <span class="n">vectors</span> <span class="o">=</span> <span class="n">xpx</span><span class="o">.</span><span class="n">atleast_nd</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xp</span><span class="p">)</span>
        <span class="n">cython_compatible</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">vectors</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">select_backend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xp</span><span class="p">,</span> <span class="n">cython_compatible</span><span class="o">=</span><span class="n">cython_compatible</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">,</span> <span class="n">vectors</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="n">inverse</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span> <span class="ow">and</span> <span class="n">single_vector</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Rotation.__mul__">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.__mul__">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Rotation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span> <span class="o">|</span> <span class="n">NotImplementedType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compose this rotation with the other.</span>

<span class="sd">        If `p` and `q` are two rotations, then the composition of &#39;q followed</span>
<span class="sd">        by p&#39; is equivalent to `p * q`. In terms of rotation matrices,</span>
<span class="sd">        the composition can be expressed as</span>
<span class="sd">        ``p.as_matrix() @ q.as_matrix()``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `Rotation` instance</span>
<span class="sd">            Object containing the rotations to be composed with this one. Note</span>
<span class="sd">            that rotation compositions are not commutative, so ``p * q`` is</span>
<span class="sd">            generally different from ``q * p``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        composition : `Rotation` instance</span>
<span class="sd">            This function supports composition of multiple rotations at a time.</span>
<span class="sd">            Composition follows standard numpy broadcasting rules. The resulting</span>
<span class="sd">            `Rotation` object will have the shape</span>
<span class="sd">            `np.broadcast_shapes(p.shape, q.shape)`. In dimensions with size &gt; 1,</span>
<span class="sd">            rotations are composed with matching indices. In dimensions with only</span>
<span class="sd">            one rotation, the single rotation is composed with each rotation in the</span>
<span class="sd">            other object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        Composition of two single rotations:</span>

<span class="sd">        &gt;&gt;&gt; p = R.from_quat([0, 0, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; q = R.from_quat([1, 0, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; p.as_matrix()</span>
<span class="sd">        array([[ 0., -1.,  0.],</span>
<span class="sd">               [ 1.,  0.,  0.],</span>
<span class="sd">               [ 0.,  0.,  1.]])</span>
<span class="sd">        &gt;&gt;&gt; q.as_matrix()</span>
<span class="sd">        array([[ 1.,  0.,  0.],</span>
<span class="sd">               [ 0.,  0., -1.],</span>
<span class="sd">               [ 0.,  1.,  0.]])</span>
<span class="sd">        &gt;&gt;&gt; r = p * q</span>
<span class="sd">        &gt;&gt;&gt; r.as_matrix()</span>
<span class="sd">        array([[0., 0., 1.],</span>
<span class="sd">               [1., 0., 0.],</span>
<span class="sd">               [0., 1., 0.]])</span>

<span class="sd">        Composition of two objects containing equal number of rotations:</span>

<span class="sd">        &gt;&gt;&gt; p = R.from_quat([[0, 0, 1, 1], [1, 0, 0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; q = R.from_rotvec([[np.pi/4, 0, 0], [-np.pi/4, 0, np.pi/4]])</span>
<span class="sd">        &gt;&gt;&gt; p.as_quat()</span>
<span class="sd">        array([[0.        , 0.        , 0.70710678, 0.70710678],</span>
<span class="sd">               [0.70710678, 0.        , 0.        , 0.70710678]])</span>
<span class="sd">        &gt;&gt;&gt; q.as_quat()</span>
<span class="sd">        array([[ 0.38268343,  0.        ,  0.        ,  0.92387953],</span>
<span class="sd">               [-0.37282173,  0.        ,  0.37282173,  0.84971049]])</span>
<span class="sd">        &gt;&gt;&gt; r = p * q</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat()</span>
<span class="sd">        array([[ 0.27059805,  0.27059805,  0.65328148,  0.65328148],</span>
<span class="sd">               [ 0.33721128, -0.26362477,  0.26362477,  0.86446082]])</span>

<span class="sd">        Broadcasting rules apply:</span>
<span class="sd">        &gt;&gt;&gt; p = R.from_quat(np.tile(np.array([0, 0, 1, 1]), (5, 1, 1)))</span>
<span class="sd">        &gt;&gt;&gt; q = R.from_quat(np.tile(np.array([1, 0, 0, 1]), (1, 6, 1)))</span>
<span class="sd">        &gt;&gt;&gt; p.shape, q.shape</span>
<span class="sd">        ((5, 1), (1, 6))</span>
<span class="sd">        &gt;&gt;&gt; r = p * q</span>
<span class="sd">        &gt;&gt;&gt; r.shape</span>
<span class="sd">        (5, 6)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that other is a Rotation object. We want to return NotImplemented</span>
        <span class="c1"># instead of raising an error to allow other types to implement __rmul__.</span>
        <span class="c1"># Python will then automatically try to delegate the multiplication to the</span>
        <span class="c1"># other type.</span>
        <span class="c1"># See https://github.com/scipy/scipy/issues/21541</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Rotation</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">broadcastable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot broadcast </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> rotations in &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;first to </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> rotations in second object.&quot;</span>
            <span class="p">)</span>
        <span class="n">cython_compatible</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">select_backend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xp</span><span class="p">,</span> <span class="n">cython_compatible</span><span class="o">=</span><span class="n">cython_compatible</span><span class="p">)</span>
        <span class="n">quat</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">compose_quat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_quat</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">_single</span><span class="p">:</span>
            <span class="n">quat</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rotation.__pow__">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.__pow__">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;cannot handle zero-length rotations&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Array</span><span class="p">,</span> <span class="n">modulus</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compose this rotation with itself `n` times.</span>

<span class="sd">        Composition of a rotation ``p`` with itself can be extended to</span>
<span class="sd">        non-integer ``n`` by considering the power ``n`` to be a scale factor</span>
<span class="sd">        applied to the angle of rotation about the rotation&#39;s fixed axis. The</span>
<span class="sd">        expression ``q = p ** n`` can also be expressed as</span>
<span class="sd">        ``q = Rotation.from_rotvec(n * p.as_rotvec())``.</span>

<span class="sd">        If ``n`` is negative, then the rotation is inverted before the power</span>
<span class="sd">        is applied. In other words, ``p ** -abs(n) == p.inv() ** abs(n)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : float | Array</span>
<span class="sd">            The number of times to compose the rotation with itself. If `n` is</span>
<span class="sd">            an array, then it must be 0d or 1d with shape (1,).</span>
<span class="sd">        modulus : None</span>
<span class="sd">            This overridden argument is not applicable to Rotations and must be</span>
<span class="sd">            ``None``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        power : `Rotation` instance</span>
<span class="sd">            The resulting rotation will be of the same shape as the original rotation</span>
<span class="sd">            object. Each element of the output is the corresponding element of the</span>
<span class="sd">            input rotation raised to the power of ``n``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For example, a power of 2 will double the angle of rotation, and a</span>
<span class="sd">        power of 0.5 will halve the angle. There are three notable cases: if</span>
<span class="sd">        ``n == 1`` then the original rotation is returned, if ``n == 0``</span>
<span class="sd">        then the identity rotation is returned, and if ``n == -1`` then</span>
<span class="sd">        ``p.inv()`` is returned.</span>

<span class="sd">        Note that fractional powers ``n`` which effectively take a root of</span>
<span class="sd">        rotation, do so using the shortest path smallest representation of that</span>
<span class="sd">        angle (the principal root). This means that powers of ``n`` and ``1/n``</span>
<span class="sd">        are not necessarily inverses of each other. For example, a 0.5 power of</span>
<span class="sd">        a +240 degree rotation will be calculated as the 0.5 power of a -120</span>
<span class="sd">        degree rotation, with the result being a rotation of -60 rather than</span>
<span class="sd">        +120 degrees.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>

<span class="sd">        Raising a rotation to a power:</span>

<span class="sd">        &gt;&gt;&gt; p = R.from_rotvec([1, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; q = p ** 2</span>
<span class="sd">        &gt;&gt;&gt; q.as_rotvec()</span>
<span class="sd">        array([2., 0., 0.])</span>
<span class="sd">        &gt;&gt;&gt; r = p ** 0.5</span>
<span class="sd">        &gt;&gt;&gt; r.as_rotvec()</span>
<span class="sd">        array([0.5, 0., 0.])</span>

<span class="sd">        Inverse powers do not necessarily cancel out:</span>

<span class="sd">        &gt;&gt;&gt; p = R.from_rotvec([0, 0, 120], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; ((p ** 2) ** 0.5).as_rotvec(degrees=True)</span>
<span class="sd">        array([  -0.,   -0., -60.])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">modulus</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;modulus not supported&quot;</span><span class="p">)</span>
        <span class="n">quat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span><span class="p">:</span>
            <span class="n">quat</span> <span class="o">=</span> <span class="n">quat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">_from_raw_quat</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xp</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rotation.inv">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.inv">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;cannot handle zero-length rotations&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Invert this rotation.</span>

<span class="sd">        Composition of a rotation with its inverse results in an identity</span>
<span class="sd">        transformation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inverse : `Rotation` instance</span>
<span class="sd">            Object containing inverse of the rotations in the current instance.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        Inverting a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; p = R.from_euler(&#39;z&#39;, 45, degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; q = p.inv()</span>
<span class="sd">        &gt;&gt;&gt; q.as_euler(&#39;zyx&#39;, degrees=True)</span>
<span class="sd">        array([-45.,   0.,   0.])</span>

<span class="sd">        Inverting multiple rotations:</span>

<span class="sd">        &gt;&gt;&gt; p = R.from_rotvec([[0, 0, np.pi/3], [-np.pi/4, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; q = p.inv()</span>
<span class="sd">        &gt;&gt;&gt; q.as_rotvec()</span>
<span class="sd">        array([[-0.        , -0.        , -1.04719755],</span>
<span class="sd">               [ 0.78539816, -0.        , -0.        ]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">q_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span><span class="p">:</span>
            <span class="n">q_inv</span> <span class="o">=</span> <span class="n">q_inv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">_from_raw_quat</span><span class="p">(</span><span class="n">q_inv</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xp</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rotation.magnitude">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.magnitude">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the magnitude(s) of the rotation(s).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        magnitude : ndarray or float</span>
<span class="sd">            Angle(s) in radians, float if object contains a single rotation</span>
<span class="sd">            and ndarray if object contains ND rotations. The magnitude</span>
<span class="sd">            will always be in the range [0, pi].</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; r = R.from_quat(np.eye(4))</span>
<span class="sd">        &gt;&gt;&gt; r.as_quat()</span>
<span class="sd">        array([[ 1., 0., 0., 0.],</span>
<span class="sd">               [ 0., 1., 0., 0.],</span>
<span class="sd">               [ 0., 0., 1., 0.],</span>
<span class="sd">               [ 0., 0., 0., 1.]])</span>
<span class="sd">        &gt;&gt;&gt; r.magnitude()</span>
<span class="sd">        array([3.14159265, 3.14159265, 3.14159265, 0.        ])</span>

<span class="sd">        Magnitude of a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; r[0].magnitude()</span>
<span class="sd">        3.141592653589793</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">magnitude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">magnitude</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span><span class="p">:</span>
            <span class="c1"># Special handling for numpy and single rotations. self._single is only set</span>
            <span class="c1"># if xp is numpy. We therefore know that magnitude is a numpy array and</span>
            <span class="c1"># that it contains a single element. Previously this code returned a Python</span>
            <span class="c1"># float in that case. Here we return a numpy float64 scalar. All other</span>
            <span class="c1"># Array API libraries return 0d arrays instead.</span>
            <span class="c1"># See https://github.com/scipy/scipy/pull/23198#issuecomment-3003757848</span>
            <span class="k">return</span> <span class="n">magnitude</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">magnitude</span></div>


<div class="viewcode-block" id="Rotation.approx_equal">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.approx_equal">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">approx_equal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Rotation</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">degrees</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine if another rotation is approximately equal to this one.</span>

<span class="sd">        Equality is measured by calculating the smallest angle between the</span>
<span class="sd">        rotations, and checking to see if it is smaller than `atol`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `Rotation` instance</span>
<span class="sd">            Object containing the rotations to measure against this one.</span>
<span class="sd">        atol : float, optional</span>
<span class="sd">            The absolute angular tolerance, below which the rotations are</span>
<span class="sd">            considered equal. If not given, then set to 1e-8 radians by</span>
<span class="sd">            default.</span>
<span class="sd">        degrees : bool, optional</span>
<span class="sd">            If True and `atol` is given, then `atol` is measured in degrees. If</span>
<span class="sd">            False (default), then atol is measured in radians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        approx_equal : ndarray or bool</span>
<span class="sd">            Whether the rotations are approximately equal, bool if object</span>
<span class="sd">            contains a single rotation and ndarray if object contains multiple</span>
<span class="sd">            rotations.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; p = R.from_quat([0, 0, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; q = R.from_quat(np.eye(4))</span>
<span class="sd">        &gt;&gt;&gt; p.approx_equal(q)</span>
<span class="sd">        array([False, False, False, True])</span>

<span class="sd">        Approximate equality for a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; p.approx_equal(q[0])</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cython_compatible</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">select_backend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xp</span><span class="p">,</span> <span class="n">cython_compatible</span><span class="o">=</span><span class="n">cython_compatible</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">backend</span><span class="o">.</span><span class="n">approx_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_quat</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="n">degrees</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rotation.mean">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.mean">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the mean of the rotations.</span>

<span class="sd">        The mean used is the chordal L2 mean (also called the projected or</span>
<span class="sd">        induced arithmetic mean) [1]_. If ``A`` is a set of rotation matrices,</span>
<span class="sd">        then the mean ``M`` is the rotation matrix that minimizes the</span>
<span class="sd">        following loss function:</span>

<span class="sd">        .. math::</span>

<span class="sd">            L(M) = \\sum_{i = 1}^{n} w_i \\lVert \\mathbf{A}_i -</span>
<span class="sd">            \\mathbf{M} \\rVert^2 ,</span>

<span class="sd">        where :math:`w_i`&#39;s are the `weights` corresponding to each matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weights : array_like shape (..., N), optional</span>
<span class="sd">            Weights describing the relative importance of the rotations. If</span>
<span class="sd">            None (default), then all values in `weights` are assumed to be</span>
<span class="sd">            equal. If given, the shape of `weights` must be broadcastable to</span>
<span class="sd">            the rotation shape. Weights must be non-negative.</span>
<span class="sd">        axis : None, int, or tuple of ints, optional</span>
<span class="sd">            Axis or axes along which the means are computed. The default is to</span>
<span class="sd">            compute the mean of all rotations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean : `Rotation` instance</span>
<span class="sd">            Single rotation containing the mean of the rotations in the</span>
<span class="sd">            current instance.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Hartley, Richard, et al.,</span>
<span class="sd">                &quot;Rotation Averaging&quot;, International Journal of Computer Vision</span>
<span class="sd">                103, 2013, pp. 267-305.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; r = R.from_euler(&#39;zyx&#39;, [[0, 0, 0],</span>
<span class="sd">        ...                          [1, 0, 0],</span>
<span class="sd">        ...                          [0, 1, 0],</span>
<span class="sd">        ...                          [0, 0, 1]], degrees=True)</span>
<span class="sd">        &gt;&gt;&gt; r.mean().as_euler(&#39;zyx&#39;, degrees=True)</span>
<span class="sd">        array([0.24945696, 0.25054542, 0.24945696])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">_from_raw_quat</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xp</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rotation.reduce">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.reduce">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reduce</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">left</span><span class="p">:</span> <span class="n">Rotation</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">right</span><span class="p">:</span> <span class="n">Rotation</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Rotation</span><span class="p">,</span> <span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reduce this rotation with the provided rotation groups.</span>

<span class="sd">        Reduction of a rotation ``p`` is a transformation of the form</span>
<span class="sd">        ``q = l * p * r``, where ``l`` and ``r`` are chosen from `left` and</span>
<span class="sd">        `right` respectively, such that rotation ``q`` has the smallest</span>
<span class="sd">        magnitude.</span>

<span class="sd">        If `left` and `right` are rotation groups representing symmetries of</span>
<span class="sd">        two objects rotated by ``p``, then ``q`` is the rotation of the</span>
<span class="sd">        smallest magnitude to align these objects considering their symmetries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        left : `Rotation` instance, optional</span>
<span class="sd">            Object containing the left rotation(s). Default value (None)</span>
<span class="sd">            corresponds to the identity rotation.</span>
<span class="sd">        right : `Rotation` instance, optional</span>
<span class="sd">            Object containing the right rotation(s). Default value (None)</span>
<span class="sd">            corresponds to the identity rotation.</span>
<span class="sd">        return_indices : bool, optional</span>
<span class="sd">            Whether to return the indices of the rotations from `left` and</span>
<span class="sd">            `right` used for reduction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reduced : `Rotation` instance</span>
<span class="sd">            Object containing reduced rotations.</span>
<span class="sd">        left_best, right_best: integer ndarray</span>
<span class="sd">            Indices of elements from `left` and `right` used for reduction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span> <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span> <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">reduced</span><span class="p">,</span> <span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span><span class="p">:</span>
            <span class="n">reduced</span> <span class="o">=</span> <span class="n">reduced</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="n">rot</span> <span class="o">=</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">_from_raw_quat</span><span class="p">(</span><span class="n">reduced</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xp</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
            <span class="n">left_idx</span> <span class="o">=</span> <span class="n">left_idx</span> <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">right_idx</span> <span class="o">=</span> <span class="n">right_idx</span> <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">rot</span><span class="p">,</span> <span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span>
        <span class="k">return</span> <span class="n">rot</span></div>


<div class="viewcode-block" id="Rotation.create_group">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.create_group">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_group</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">group</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Z&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a 3D rotation group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        group : string</span>
<span class="sd">            The name of the group. Must be one of &#39;I&#39;, &#39;O&#39;, &#39;T&#39;, &#39;Dn&#39;, &#39;Cn&#39;,</span>
<span class="sd">            where `n` is a positive integer. The groups are:</span>

<span class="sd">                * I: Icosahedral group</span>
<span class="sd">                * O: Octahedral group</span>
<span class="sd">                * T: Tetrahedral group</span>
<span class="sd">                * D: Dicyclic group</span>
<span class="sd">                * C: Cyclic group</span>

<span class="sd">        axis : integer</span>
<span class="sd">            The cyclic rotation axis. Must be one of [&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;] (or</span>
<span class="sd">            lowercase). Default is &#39;Z&#39;. Ignored for groups &#39;I&#39;, &#39;O&#39;, and &#39;T&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotation : `Rotation` instance</span>
<span class="sd">            Object containing the elements of the rotation group.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method generates rotation groups only. The full 3-dimensional</span>
<span class="sd">        point groups [PointGroups]_ also contain reflections.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [PointGroups] `Point groups</span>
<span class="sd">           &lt;https://en.wikipedia.org/wiki/Point_groups_in_three_dimensions&gt;`_</span>
<span class="sd">           on Wikipedia.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: We defer the implementation of groups for arbitrary Array API frameworks</span>
        <span class="c1"># to the follow-up PR that adds general Array API support for Rotations.</span>
        <span class="k">return</span> <span class="n">create_group</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rotation.__getitem__">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.__getitem__">[docs]</a>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">jax_jit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;cannot handle zero-length rotations&quot;</span><span class="p">)],</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexer</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">slice</span> <span class="o">|</span> <span class="n">EllipsisType</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract rotation(s) at given index(es) from object.</span>

<span class="sd">        Create a new `Rotation` instance containing a subset of rotations</span>
<span class="sd">        stored in this object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexer : index, slice, or index array</span>
<span class="sd">            Specifies which rotation(s) to extract. A single indexer must be</span>
<span class="sd">            specified, i.e. as if indexing a 1 dimensional array or list.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotation : `Rotation` instance</span>
<span class="sd">            Contains</span>
<span class="sd">                - a single rotation, if `indexer` is a single index</span>
<span class="sd">                - a stack of rotation(s), if `indexer` is a slice, or and index</span>
<span class="sd">                  array.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError if the instance was created as a single rotation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">        &gt;&gt;&gt; rs = R.from_quat([</span>
<span class="sd">        ... [1, 1, 0, 0],</span>
<span class="sd">        ... [0, 1, 0, 1],</span>
<span class="sd">        ... [1, 1, -1, 0]])  # These quats are normalized</span>
<span class="sd">        &gt;&gt;&gt; rs.as_quat()</span>
<span class="sd">        array([[ 0.70710678,  0.70710678,  0.        ,  0.        ],</span>
<span class="sd">               [ 0.        ,  0.70710678,  0.        ,  0.70710678],</span>
<span class="sd">               [ 0.57735027,  0.57735027, -0.57735027,  0.        ]])</span>

<span class="sd">        Indexing using a single index:</span>

<span class="sd">        &gt;&gt;&gt; a = rs[0]</span>
<span class="sd">        &gt;&gt;&gt; a.as_quat()</span>
<span class="sd">        array([0.70710678, 0.70710678, 0.        , 0.        ])</span>

<span class="sd">        Array slicing:</span>

<span class="sd">        &gt;&gt;&gt; b = rs[1:3]</span>
<span class="sd">        &gt;&gt;&gt; b.as_quat()</span>
<span class="sd">        array([[ 0.        ,  0.70710678,  0.        ,  0.70710678],</span>
<span class="sd">               [ 0.57735027,  0.57735027, -0.57735027,  0.        ]])</span>

<span class="sd">        List comprehension to split each rotation into its own object:</span>

<span class="sd">        &gt;&gt;&gt; c = [r for r in rs]</span>
<span class="sd">        &gt;&gt;&gt; print([r.as_quat() for r in c])</span>
<span class="sd">        [array([ 0.70710678,  0.70710678,  0.        ,  0.        ]),</span>
<span class="sd">         array([ 0.        ,  0.70710678,  0.        ,  0.70710678]),</span>
<span class="sd">         array([ 0.57735027,  0.57735027, -0.57735027,  0.        ])]</span>

<span class="sd">        Concatenation of split rotations will recover the original object:</span>

<span class="sd">        &gt;&gt;&gt; R.concatenate([a, b]).as_quat()</span>
<span class="sd">        array([[ 0.70710678,  0.70710678,  0.        ,  0.        ],</span>
<span class="sd">               [ 0.        ,  0.70710678,  0.        ,  0.70710678],</span>
<span class="sd">               [ 0.57735027,  0.57735027, -0.57735027,  0.        ]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Single rotation is not subscriptable.&quot;</span><span class="p">)</span>
        <span class="n">is_array</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">))</span>
        <span class="c1"># Masking is only specified in the Array API when the array is the sole index</span>
        <span class="c1"># TODO: This special case handling is mainly a result of Array API limitations.</span>
        <span class="c1"># Ideally we would get rid of them altogether and converge to [indexer, ...]</span>
        <span class="c1"># indexing.</span>
        <span class="k">if</span> <span class="n">is_array</span> <span class="ow">and</span> <span class="n">indexer</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xp</span><span class="o">.</span><span class="n">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Rotation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">[</span><span class="n">indexer</span><span class="p">],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_array</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xp</span><span class="o">.</span><span class="n">isdtype</span><span class="p">(</span><span class="n">indexer</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;integral&quot;</span><span class="p">):</span>
            <span class="c1"># xp.take is implementation-defined for zero-dim arrays, hence we raise</span>
            <span class="c1"># pre-emptively to have consistent behavior across frameworks.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;cannot do a non-empty take from an empty axes.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Rotation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xp</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">[</span><span class="n">indexer</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">jax_jit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;cannot handle zero-length rotations&quot;</span><span class="p">)],</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexer</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">slice</span> <span class="o">|</span> <span class="n">EllipsisType</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Rotation</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set rotation(s) at given index(es) from object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexer : index, slice, or index array</span>
<span class="sd">            Specifies which rotation(s) to replace. A single indexer must be</span>
<span class="sd">            specified, i.e. as if indexing a 1 dimensional array or list.</span>

<span class="sd">        value : `Rotation` instance</span>
<span class="sd">            The rotations to set.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError if the instance was created as a single rotation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        .. versionadded:: 1.8.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Single rotation is not subscriptable.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Rotation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;value must be a Rotation object&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">setitem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">as_quat</span><span class="p">(),</span> <span class="n">indexer</span><span class="p">)</span>

<div class="viewcode-block" id="Rotation.identity">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.identity">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">identity</span><span class="p">(</span>
        <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get identity rotation(s).</span>

<span class="sd">        Composition with the identity rotation has no effect.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num : int or None, optional</span>
<span class="sd">            Number of identity rotations to generate. If None (default), then a</span>
<span class="sd">            single rotation is generated.</span>
<span class="sd">        shape : int or tuple of ints, optional</span>
<span class="sd">            Shape of identity rotations to generate. If specified, `num` must</span>
<span class="sd">            be None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        identity : Rotation object</span>
<span class="sd">            The identity rotation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: We should move to one single way of specifying the output shape and</span>
        <span class="c1"># deprecate `num`.</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of `num` or `shape` can be specified.&quot;</span><span class="p">)</span>
        <span class="n">quat</span> <span class="o">=</span> <span class="n">cython_backend</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">_from_raw_quat</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">array_namespace</span><span class="p">(</span><span class="n">quat</span><span class="p">))</span></div>


<div class="viewcode-block" id="Rotation.random">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.random">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@_transition_to_rng</span><span class="p">(</span><span class="s2">&quot;random_state&quot;</span><span class="p">,</span> <span class="n">position_num</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">random</span><span class="p">(</span>
        <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">rng</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate rotations that are uniformly distributed on a sphere.</span>

<span class="sd">        Formally, the rotations follow the Haar-uniform distribution over the SO(3)</span>
<span class="sd">        group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num : int or None, optional</span>
<span class="sd">            Number of random rotations to generate. If None (default), then a</span>
<span class="sd">            single rotation is generated.</span>
<span class="sd">        rng : `numpy.random.Generator`, optional</span>
<span class="sd">            Pseudorandom number generator state. When `rng` is None, a new</span>
<span class="sd">            `numpy.random.Generator` is created using entropy from the</span>
<span class="sd">            operating system. Types other than `numpy.random.Generator` are</span>
<span class="sd">            passed to `numpy.random.default_rng` to instantiate a `Generator`.</span>
<span class="sd">        shape : tuple of ints, optional</span>
<span class="sd">            Shape of random rotations to generate. If specified, `num` must be None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        random_rotation : `Rotation` instance</span>
<span class="sd">            Contains a single rotation if `num` is None. Otherwise contains a</span>
<span class="sd">            stack of `num` rotations.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function is optimized for efficiently sampling random rotation</span>
<span class="sd">        matrices in three dimensions. For generating random rotation matrices</span>
<span class="sd">        in higher dimensions, see `scipy.stats.special_ortho_group`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>

<span class="sd">        Sample a single rotation:</span>

<span class="sd">        &gt;&gt;&gt; R.random().as_euler(&#39;zxy&#39;, degrees=True)</span>
<span class="sd">        array([-110.5976185 ,   55.32758512,   76.3289269 ])  # random</span>

<span class="sd">        Sample a stack of rotations:</span>

<span class="sd">        &gt;&gt;&gt; R.random(5).as_euler(&#39;zxy&#39;, degrees=True)</span>
<span class="sd">        array([[-110.5976185 ,   55.32758512,   76.3289269 ],  # random</span>
<span class="sd">               [ -91.59132005,  -14.3629884 ,  -93.91933182],</span>
<span class="sd">               [  25.23835501,   45.02035145, -121.67867086],</span>
<span class="sd">               [ -51.51414184,  -15.29022692, -172.46870023],</span>
<span class="sd">               [ -81.63376847,  -27.39521579,    2.60408416]])</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.stats.special_ortho_group</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: We should move to one single way of specifying the output shape and</span>
        <span class="c1"># deprecate `num`.</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of `num` or `shape` can be specified.&quot;</span><span class="p">)</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">cython_backend</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rotation.align_vectors">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.align_vectors">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions and .mT attribute&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;cupy&quot;</span><span class="p">,</span> <span class="s2">&quot;missing .mT attribute in cupy&lt;14.*&quot;</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">align_vectors</span><span class="p">(</span>
        <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">b</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_sensitivity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Rotation</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Rotation</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Estimate a rotation to optimally align two sets of vectors.</span>

<span class="sd">        Find a rotation between frames A and B which best aligns a set of</span>
<span class="sd">        vectors `a` and `b` observed in these frames. The following loss</span>
<span class="sd">        function is minimized to solve for the rotation matrix</span>
<span class="sd">        :math:`C`:</span>

<span class="sd">        .. math::</span>

<span class="sd">            L(C) = \\frac{1}{2} \\sum_{i = 1}^{n} w_i \\lVert \\mathbf{a}_i -</span>
<span class="sd">            C \\mathbf{b}_i \\rVert^2 ,</span>

<span class="sd">        where :math:`w_i`&#39;s are the `weights` corresponding to each vector.</span>

<span class="sd">        The rotation is estimated with Kabsch algorithm [1]_, and solves what</span>
<span class="sd">        is known as the &quot;pointing problem&quot;, or &quot;Wahba&#39;s problem&quot; [2]_.</span>

<span class="sd">        Note that the length of each vector in this formulation acts as an</span>
<span class="sd">        implicit weight. So for use cases where all vectors need to be</span>
<span class="sd">        weighted equally, you should normalize them to unit length prior to</span>
<span class="sd">        calling this method.</span>

<span class="sd">        There are two special cases. The first is if a single vector is given</span>
<span class="sd">        for `a` and `b`, in which the shortest distance rotation that aligns</span>
<span class="sd">        `b` to `a` is returned.</span>

<span class="sd">        The second is when one of the weights is infinity. In this case, the</span>
<span class="sd">        shortest distance rotation between the primary infinite weight vectors</span>
<span class="sd">        is calculated as above. Then, the rotation about the aligned primary</span>
<span class="sd">        vectors is calculated such that the secondary vectors are optimally</span>
<span class="sd">        aligned per the above loss function. The result is the composition</span>
<span class="sd">        of these two rotations. The result via this process is the same as the</span>
<span class="sd">        Kabsch algorithm as the corresponding weight approaches infinity in</span>
<span class="sd">        the limit. For a single secondary vector this is known as the</span>
<span class="sd">        &quot;align-constrain&quot; algorithm [3]_.</span>

<span class="sd">        For both special cases (single vectors or an infinite weight), the</span>
<span class="sd">        sensitivity matrix does not have physical meaning and an error will be</span>
<span class="sd">        raised if it is requested. For an infinite weight, the primary vectors</span>
<span class="sd">        act as a constraint with perfect alignment, so their contribution to</span>
<span class="sd">        `rssd` will be forced to 0 even if they are of different lengths.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : array_like, shape (3,) or (N, 3)</span>
<span class="sd">            Vector components observed in initial frame A. Each row of `a`</span>
<span class="sd">            denotes a vector.</span>
<span class="sd">        b : array_like, shape (3,) or (N, 3)</span>
<span class="sd">            Vector components observed in another frame B. Each row of `b`</span>
<span class="sd">            denotes a vector.</span>
<span class="sd">        weights : array_like shape (N,), optional</span>
<span class="sd">            Weights describing the relative importance of the vector</span>
<span class="sd">            observations. If None (default), then all values in `weights` are</span>
<span class="sd">            assumed to be 1. One and only one weight may be infinity, and</span>
<span class="sd">            weights must be positive.</span>
<span class="sd">        return_sensitivity : bool, optional</span>
<span class="sd">            Whether to return the sensitivity matrix. See Notes for details.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotation : `Rotation` instance</span>
<span class="sd">            Best estimate of the rotation that transforms `b` to `a`.</span>
<span class="sd">        rssd : float</span>
<span class="sd">            Stands for &quot;root sum squared distance&quot;. Square root of the weighted</span>
<span class="sd">            sum of the squared distances between the given sets of vectors</span>
<span class="sd">            after alignment. It is equal to ``sqrt(2 * minimum_loss)``, where</span>
<span class="sd">            ``minimum_loss`` is the loss function evaluated for the found</span>
<span class="sd">            optimal rotation.</span>
<span class="sd">            Note that the result will also be weighted by the vectors&#39;</span>
<span class="sd">            magnitudes, so perfectly aligned vector pairs will have nonzero</span>
<span class="sd">            `rssd` if they are not of the same length. This can be avoided by</span>
<span class="sd">            normalizing them to unit length prior to calling this method,</span>
<span class="sd">            though note that doing this will change the resulting rotation.</span>
<span class="sd">        sensitivity_matrix : ndarray, shape (3, 3)</span>
<span class="sd">            Sensitivity matrix of the estimated rotation estimate as explained</span>
<span class="sd">            in Notes. Returned only when `return_sensitivity` is True. Not</span>
<span class="sd">            valid if aligning a single pair of vectors or if there is an</span>
<span class="sd">            infinite weight, in which cases an error will be raised.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The sensitivity matrix gives the sensitivity of the estimated rotation</span>
<span class="sd">        to small perturbations of the vector measurements. Specifically we</span>
<span class="sd">        consider the rotation estimate error as a small rotation vector of</span>
<span class="sd">        frame A. The sensitivity matrix is proportional to the covariance of</span>
<span class="sd">        this rotation vector assuming that the vectors in `a` was measured with</span>
<span class="sd">        errors significantly less than their lengths. To get the true</span>
<span class="sd">        covariance matrix, the returned sensitivity matrix must be multiplied</span>
<span class="sd">        by harmonic mean [4]_ of variance in each observation. Note that</span>
<span class="sd">        `weights` are supposed to be inversely proportional to the observation</span>
<span class="sd">        variances to get consistent results. For example, if all vectors are</span>
<span class="sd">        measured with the same accuracy of 0.01 (`weights` must be all equal),</span>
<span class="sd">        then you should multiple the sensitivity matrix by 0.01**2 to get the</span>
<span class="sd">        covariance.</span>

<span class="sd">        Refer to [5]_ for more rigorous discussion of the covariance</span>
<span class="sd">        estimation. See [6]_ for more discussion of the pointing problem and</span>
<span class="sd">        minimal proper pointing.</span>

<span class="sd">        This function does not support broadcasting or ND arrays with N &gt; 2.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Kabsch_algorithm</span>
<span class="sd">        .. [2] https://en.wikipedia.org/wiki/Wahba%27s_problem</span>
<span class="sd">        .. [3] Magner, Robert,</span>
<span class="sd">                &quot;Extending target tracking capabilities through trajectory and</span>
<span class="sd">                momentum setpoint optimization.&quot; Small Satellite Conference,</span>
<span class="sd">                2018.</span>
<span class="sd">        .. [4] https://en.wikipedia.org/wiki/Harmonic_mean</span>
<span class="sd">        .. [5] F. Landis Markley,</span>
<span class="sd">                &quot;Attitude determination using vector observations: a fast</span>
<span class="sd">                optimal matrix algorithm&quot;, Journal of Astronautical Sciences,</span>
<span class="sd">                Vol. 41, No.2, 1993, pp. 261-280.</span>
<span class="sd">        .. [6] Bar-Itzhack, Itzhack Y., Daniel Hershkowitz, and Leiba Rodman,</span>
<span class="sd">                &quot;Pointing in Real Euclidean Space&quot;, Journal of Guidance,</span>
<span class="sd">                Control, and Dynamics, Vol. 20, No. 5, 1997, pp. 916-922.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>

<span class="sd">        Here we run the baseline Kabsch algorithm to best align two sets of</span>
<span class="sd">        vectors, where there is noise on the last two vector measurements of</span>
<span class="sd">        the ``b`` set:</span>

<span class="sd">        &gt;&gt;&gt; a = [[0, 1, 0], [0, 1, 1], [0, 1, 1]]</span>
<span class="sd">        &gt;&gt;&gt; b = [[1, 0, 0], [1, 1.1, 0], [1, 0.9, 0]]</span>
<span class="sd">        &gt;&gt;&gt; rot, rssd, sens = R.align_vectors(a, b, return_sensitivity=True)</span>
<span class="sd">        &gt;&gt;&gt; rot.as_matrix()</span>
<span class="sd">        array([[0., 0., 1.],</span>
<span class="sd">               [1., 0., 0.],</span>
<span class="sd">               [0., 1., 0.]])</span>

<span class="sd">        When we apply the rotation to ``b``, we get vectors close to ``a``:</span>

<span class="sd">        &gt;&gt;&gt; rot.apply(b)</span>
<span class="sd">        array([[0. , 1. , 0. ],</span>
<span class="sd">               [0. , 1. , 1.1],</span>
<span class="sd">               [0. , 1. , 0.9]])</span>

<span class="sd">        The error for the first vector is 0, and for the last two the error is</span>
<span class="sd">        magnitude 0.1. The `rssd` is the square root of the sum of the</span>
<span class="sd">        weighted squared errors, and the default weights are all 1, so in this</span>
<span class="sd">        case the `rssd` is calculated as</span>
<span class="sd">        ``sqrt(1 * 0**2 + 1 * 0.1**2 + 1 * (-0.1)**2) = 0.141421356237308``</span>

<span class="sd">        &gt;&gt;&gt; a - rot.apply(b)</span>
<span class="sd">        array([[ 0., 0.,  0. ],</span>
<span class="sd">               [ 0., 0., -0.1],</span>
<span class="sd">               [ 0., 0.,  0.1]])</span>
<span class="sd">        &gt;&gt;&gt; np.sqrt(np.sum(np.ones(3) @ (a - rot.apply(b))**2))</span>
<span class="sd">        0.141421356237308</span>
<span class="sd">        &gt;&gt;&gt; rssd</span>
<span class="sd">        0.141421356237308</span>

<span class="sd">        The sensitivity matrix for this example is as follows:</span>

<span class="sd">        &gt;&gt;&gt; sens</span>
<span class="sd">        array([[0.2, 0. , 0.],</span>
<span class="sd">               [0. , 1.5, 1.],</span>
<span class="sd">               [0. , 1. , 1.]])</span>

<span class="sd">        Special case 1: Find a minimum rotation between single vectors:</span>

<span class="sd">        &gt;&gt;&gt; a = [1, 0, 0]</span>
<span class="sd">        &gt;&gt;&gt; b = [0, 1, 0]</span>
<span class="sd">        &gt;&gt;&gt; rot, _ = R.align_vectors(a, b)</span>
<span class="sd">        &gt;&gt;&gt; rot.as_matrix()</span>
<span class="sd">        array([[0., 1., 0.],</span>
<span class="sd">               [-1., 0., 0.],</span>
<span class="sd">               [0., 0., 1.]])</span>
<span class="sd">        &gt;&gt;&gt; rot.apply(b)</span>
<span class="sd">        array([1., 0., 0.])</span>

<span class="sd">        Special case 2: One infinite weight. Here we find a rotation between</span>
<span class="sd">        primary and secondary vectors that can align exactly:</span>

<span class="sd">        &gt;&gt;&gt; a = [[0, 1, 0], [0, 1, 1]]</span>
<span class="sd">        &gt;&gt;&gt; b = [[1, 0, 0], [1, 1, 0]]</span>
<span class="sd">        &gt;&gt;&gt; rot, _ = R.align_vectors(a, b, weights=[np.inf, 1])</span>
<span class="sd">        &gt;&gt;&gt; rot.as_matrix()</span>
<span class="sd">        array([[0., 0., 1.],</span>
<span class="sd">               [1., 0., 0.],</span>
<span class="sd">               [0., 1., 0.]])</span>
<span class="sd">        &gt;&gt;&gt; rot.apply(b)</span>
<span class="sd">        array([[0., 1., 0.],</span>
<span class="sd">               [0., 1., 1.]])</span>

<span class="sd">        Here the secondary vectors must be best-fit:</span>

<span class="sd">        &gt;&gt;&gt; a = [[0, 1, 0], [0, 1, 1]]</span>
<span class="sd">        &gt;&gt;&gt; b = [[1, 0, 0], [1, 2, 0]]</span>
<span class="sd">        &gt;&gt;&gt; rot, _ = R.align_vectors(a, b, weights=[np.inf, 1])</span>
<span class="sd">        &gt;&gt;&gt; rot.as_matrix()</span>
<span class="sd">        array([[0., 0., 1.],</span>
<span class="sd">               [1., 0., 0.],</span>
<span class="sd">               [0., 1., 0.]])</span>
<span class="sd">        &gt;&gt;&gt; rot.apply(b)</span>
<span class="sd">        array([[0., 1., 0.],</span>
<span class="sd">               [0., 1., 2.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">array_namespace</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_promote</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span>
        <span class="n">cython_compatible</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">weights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">select_backend</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">cython_compatible</span><span class="o">=</span><span class="n">cython_compatible</span><span class="p">)</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">rssd</span><span class="p">,</span> <span class="n">sensitivity</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">align_vectors</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">return_sensitivity</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_sensitivity</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">_from_raw_quat</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">),</span> <span class="n">rssd</span><span class="p">,</span> <span class="n">sensitivity</span>
        <span class="k">return</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">_from_raw_quat</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">),</span> <span class="n">rssd</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]):</span>
        <span class="n">quat</span><span class="p">,</span> <span class="n">single</span> <span class="o">=</span> <span class="n">state</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">array_namespace</span><span class="p">(</span><span class="n">quat</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xp</span> <span class="o">=</span> <span class="n">xp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span> <span class="o">=</span> <span class="n">select_backend</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">cython_compatible</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_single</span> <span class="o">=</span> <span class="n">single</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">single</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether this instance represents a single rotation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The shape of the rotation&#39;s leading dimensions.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Comply with Python convention for objects to be True.</span>

<span class="sd">        Required because `Rotation.__len__()` is defined and not always truthy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="Rotation.__len__">
<a class="viewcode-back" href="../../../../api/astrix.spatial.html#astrix.spatial.Rotation.__len__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of rotations contained in this object.</span>

<span class="sd">        Multiple rotations can be stored in a single instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        length : int</span>
<span class="sd">            Number of rotations stored in object.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError if the instance was created as a single rotation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Single rotation has no len().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross/det functions&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="c1"># bump indent (+21 characters)</span>
        <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="mi">21</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">))]</span>
        <span class="k">return</span> <span class="s2">&quot;Rotation.from_matrix(&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>

    <span class="nd">@xp_capabilities</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Rotation</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over rotations.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Single rotation is not iterable.&quot;</span><span class="p">)</span>
        <span class="c1"># We return a generator that yields a new Rotation object for each rotation</span>
        <span class="c1"># in the current object. We cannot rely on the default implementation using</span>
        <span class="c1"># __getitem__ because jax will not raise an IndexError for out-of-bounds</span>
        <span class="c1"># indices.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">yield</span> <span class="n">Rotation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_from_raw_quat</span><span class="p">(</span>
        <span class="n">quat</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">xp</span><span class="p">:</span> <span class="n">ModuleType</span><span class="p">,</span> <span class="n">backend</span><span class="p">:</span> <span class="n">ModuleType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Rotation skipping all sanitization steps.</span>

<span class="sd">        This method is intended for internal, performant creation of Rotations with</span>
<span class="sd">        quaternions that are guaranteed to be valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rot</span> <span class="o">=</span> <span class="n">Rotation</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">Rotation</span><span class="p">)</span>
        <span class="n">rot</span><span class="o">.</span><span class="n">_single</span> <span class="o">=</span> <span class="n">quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">is_numpy</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rot</span><span class="o">.</span><span class="n">_single</span><span class="p">:</span>
            <span class="n">quat</span> <span class="o">=</span> <span class="n">xpx</span><span class="o">.</span><span class="n">atleast_nd</span><span class="p">(</span><span class="n">quat</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span>
        <span class="n">rot</span><span class="o">.</span><span class="n">_quat</span> <span class="o">=</span> <span class="n">quat</span>
        <span class="n">rot</span><span class="o">.</span><span class="n">_xp</span> <span class="o">=</span> <span class="n">xp</span>
        <span class="k">if</span> <span class="n">backend</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">backend</span> <span class="o">=</span> <span class="n">select_backend</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">cython_compatible</span><span class="o">=</span><span class="n">quat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">rot</span><span class="o">.</span><span class="n">_backend</span> <span class="o">=</span> <span class="n">backend</span>
        <span class="k">return</span> <span class="n">rot</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">Slerp</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Spherical Linear Interpolation of Rotations.</span>

<span class="sd">    The interpolation between consecutive rotations is performed as a rotation</span>
<span class="sd">    around a fixed axis with a constant angular velocity [1]_. This ensures</span>
<span class="sd">    that the interpolated rotations follow the shortest path between initial</span>
<span class="sd">    and final orientations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : array_like, shape (N,)</span>
<span class="sd">        Times of the known rotations. At least 2 times must be specified.</span>
<span class="sd">    rotations : `Rotation` instance</span>
<span class="sd">        Rotations to perform the interpolation between. Must contain N</span>
<span class="sd">        rotations.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Rotation</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class only supports interpolation of rotations with a single leading</span>
<span class="sd">    dimension.</span>

<span class="sd">    .. versionadded:: 1.2.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Slerp#Quaternion_Slerp</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial.transform import Rotation as R</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial.transform import Slerp</span>

<span class="sd">    Setup the fixed keyframe rotations and times:</span>

<span class="sd">    &gt;&gt;&gt; key_rots = R.random(5, random_state=2342345)</span>
<span class="sd">    &gt;&gt;&gt; key_times = [0, 1, 2, 3, 4]</span>

<span class="sd">    Create the interpolator object:</span>

<span class="sd">    &gt;&gt;&gt; slerp = Slerp(key_times, key_rots)</span>

<span class="sd">    Interpolate the rotations at the given times:</span>

<span class="sd">    &gt;&gt;&gt; times = [0, 0.5, 0.25, 1, 1.5, 2, 2.75, 3, 3.25, 3.60, 4]</span>
<span class="sd">    &gt;&gt;&gt; interp_rots = slerp(times)</span>

<span class="sd">    The keyframe rotations expressed as Euler angles:</span>

<span class="sd">    &gt;&gt;&gt; key_rots.as_euler(&#39;xyz&#39;, degrees=True)</span>
<span class="sd">    array([[ 14.31443779, -27.50095894,  -3.7275787 ],</span>
<span class="sd">           [ -1.79924227, -24.69421529, 164.57701743],</span>
<span class="sd">           [146.15020772,  43.22849451, -31.34891088],</span>
<span class="sd">           [ 46.39959442,  11.62126073, -45.99719267],</span>
<span class="sd">           [-88.94647804, -49.64400082, -65.80546984]])</span>

<span class="sd">    The interpolated rotations expressed as Euler angles. These agree with the</span>
<span class="sd">    keyframe rotations at both endpoints of the range of keyframe times.</span>

<span class="sd">    &gt;&gt;&gt; interp_rots.as_euler(&#39;xyz&#39;, degrees=True)</span>
<span class="sd">    array([[  14.31443779,  -27.50095894,   -3.7275787 ],</span>
<span class="sd">           [   4.74588574,  -32.44683966,   81.25139984],</span>
<span class="sd">           [  10.71094749,  -31.56690154,   38.06896408],</span>
<span class="sd">           [  -1.79924227,  -24.69421529,  164.57701743],</span>
<span class="sd">           [  11.72796022,   51.64207311, -171.7374683 ],</span>
<span class="sd">           [ 146.15020772,   43.22849451,  -31.34891088],</span>
<span class="sd">           [  68.10921869,   20.67625074,  -48.74886034],</span>
<span class="sd">           [  46.39959442,   11.62126073,  -45.99719267],</span>
<span class="sd">           [  12.35552615,    4.21525086,  -64.89288124],</span>
<span class="sd">           [ -30.08117143,  -19.90769513,  -78.98121326],</span>
<span class="sd">           [ -88.94647804,  -49.64400082,  -65.80546984]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@xp_capabilities</span><span class="p">(</span>
        <span class="n">jax_jit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_backends</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;dask.array&quot;</span><span class="p">,</span> <span class="s2">&quot;missing linalg.cross function&quot;</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">rotations</span><span class="p">:</span> <span class="n">Rotation</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rotations</span><span class="p">,</span> <span class="n">Rotation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`rotations` must be a `Rotation` instance.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rotations</span><span class="o">.</span><span class="n">single</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">rotations</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`rotations` must be a sequence of at least 2 rotations.&quot;</span><span class="p">)</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">rotations</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Rotations with more than 1 leading dimension are not supported.&quot;</span>
            <span class="p">)</span>

        <span class="n">xp</span> <span class="o">=</span> <span class="n">array_namespace</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">xp_device</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">times</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Expected times to be specified in a 1 dimensional array, got &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">times</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dimensions.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rotations</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Expected number of rotations to be equal to number of timestamps &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;given, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">rotations</span><span class="p">)</span><span class="si">}</span><span class="s2"> rotations and </span><span class="si">{</span><span class="n">times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;timestamps.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timedelta</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

        <span class="c1"># We cannot check for values for lazy backends, so we cannot raise an error on</span>
        <span class="c1"># timedelta &lt; 0 for lazy backends. Instead, we set timedelta to nans</span>
        <span class="n">neg_mask</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timedelta</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_lazy_array</span><span class="p">(</span><span class="n">neg_mask</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timedelta</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">neg_mask</span><span class="p">,</span> <span class="n">xp</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timedelta</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">neg_mask</span><span class="p">,</span> <span class="n">xp</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">xp</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">neg_mask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Times must be in strictly increasing order.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rotations</span> <span class="o">=</span> <span class="n">rotations</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotvecs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="o">*</span> <span class="n">rotations</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>

    <span class="nd">@xp_capabilities</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Rotation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate rotations.</span>

<span class="sd">        Compute the interpolated rotations at the given `times`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : array_like</span>
<span class="sd">            Times to compute the interpolations at. Can be a scalar or</span>
<span class="sd">            1-dimensional.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        interpolated_rotation : `Rotation` instance</span>
<span class="sd">            Object containing the rotations computed at given `times`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">array_namespace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">xp_device</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
        <span class="c1"># Clearly differentiate from self.times property</span>
        <span class="n">compute_times</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compute_times</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`times` must be at most 1-dimensional.&quot;</span><span class="p">)</span>

        <span class="n">single_time</span> <span class="o">=</span> <span class="n">compute_times</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">compute_times</span> <span class="o">=</span> <span class="n">xpx</span><span class="o">.</span><span class="n">atleast_nd</span><span class="p">(</span><span class="n">compute_times</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span>

        <span class="c1"># side = &#39;left&#39; (default) excludes t_min.</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">compute_times</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># Include t_min. Without this step, index for t_min equals -1</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">xpx</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">compute_times</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># We cannot error out on invalid indices for jit compiled code. To not produce</span>
        <span class="c1"># an index error, we set the index to 0 in case it is out of bounds, and later</span>
        <span class="c1"># set the result to nan.</span>
        <span class="n">invalid_ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ind</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotations</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_lazy_array</span><span class="p">(</span><span class="n">invalid_ind</span><span class="p">):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">xpx</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">invalid_ind</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">xp</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">invalid_ind</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Interpolation times must be within the range [</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">], both inclusive.&quot;</span>
            <span class="p">)</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">compute_times</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">timedelta</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">xpx</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">invalid_ind</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xp</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># The array API does not support integer arrays + ellipsis indexing and won&#39;t</span>
        <span class="c1"># stabilize this feature due to blockers in PyTorch. Therefore we need to</span>
        <span class="c1"># construct the index for the last dimension manually.</span>
        <span class="c1"># See https://github.com/scipy/scipy/pull/23249#discussion_r2198363047</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotations</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">Rotation</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotvecs</span><span class="p">[</span><span class="n">ind</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)]</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">single_time</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, Andrew Lock
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../../_static/documentation_options.js?v=8a448e45"></script>
    <script src="../../../../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../../../_static/scripts/furo.js?v=46bd48cc"></script>
    </body>
</html>